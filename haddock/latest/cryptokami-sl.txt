-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cryptokami SL main implementation
--   
--   Please see README.md
@package cryptokami-sl
@version 0.4.4


-- | Secret key file storage and management functions based on file
--   locking.
module Pos.Util.UserSecret

-- | User secret data. Includes secret keys only for now (not including
--   auxiliary <tt>_usPath</tt>).
data UserSecret
usKeys :: Lens' UserSecret [EncryptedSecretKey]
usVss :: Lens' UserSecret (Maybe VssKeyPair)
usPrimKey :: Lens' UserSecret (Maybe SecretKey)
getUSPath :: UserSecret -> FilePath

-- | Create a simple UserSecret from secret key and file path
simpleUserSecret :: SecretKey -> FilePath -> UserSecret

-- | Create user secret file at the given path, but only when one doesn't
--   already exist.
initializeUserSecret :: (MonadIO m, WithLogger m) => FilePath -> m ()

-- | Reads user secret from file, assuming that file exists, and has mode
--   600, throws exception in other case
readUserSecret :: (MonadIO m, WithLogger m) => FilePath -> m UserSecret

-- | Reads user secret from the given file. If the file does not exist/is
--   empty, returns empty user secret
peekUserSecret :: (MonadIO m, WithLogger m) => FilePath -> m UserSecret

-- | Read user secret putting an exclusive lock on it. To unlock, use
--   <a>writeUserSecretRelease</a>.
takeUserSecret :: (MonadIO m, WithLogger m) => FilePath -> m UserSecret

-- | Writes user secret .
writeUserSecret :: (MonadIO m) => UserSecret -> m ()

-- | Writes user secret and releases the lock. UserSecret can't be used
--   after this function call anymore.
writeUserSecretRelease :: (MonadFail m, MonadIO m) => UserSecret -> m ()
instance GHC.Show.Show Pos.Util.UserSecret.UserSecret
instance Data.Default.Class.Default Pos.Util.UserSecret.UserSecret
instance Pos.Binary.Class.Bi Pos.Util.UserSecret.UserSecret


-- | Miscellaneous unclassified utility functions.
module Pos.Util

-- | Type for generating list of unique (nonrepeating) elemets.
class Nonrepeating a
nonrepeating :: Nonrepeating a => Int -> Gen [a]

-- | ArbitraryUnsafe class ~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   This class is the same as <a>Arbitrary</a>, except instances of this
--   class for stuff like public/secret keys, VSS shares, commitments etc.
--   are designed not to mimic real data as presisely as possible (using
--   OpenSSL random), but rather to be simple and efficient.
--   
--   This is especially useful for benchmarking.
--   
--   Note: we don't need <a>Generic</a> to derive instances of
--   <a>ArbitraryUnsafe</a>. We can either use one-line instance
--   declaration, or <tt>-XStandaloneDeriving</tt> or
--   <tt>-XDeriveAnyClass</tt> to write something like <tt>deriving
--   (Arbitrary, ArbitraryUnsafe)</tt>.
class ArbitraryUnsafe a where arbitraryUnsafe = arbitrary
arbitraryUnsafe :: ArbitraryUnsafe a => Gen a
arbitraryUnsafe :: (ArbitraryUnsafe a, Arbitrary a) => Gen a
makeSmall :: Gen a -> Gen a

-- | Choose a random (shuffled) subset of length n. Throws an error if
--   there's not enough elements.
sublistN :: Int -> [a] -> Gen [a]

-- | Unsafely create list of <tt>n</tt> random values to be picked (see
--   note in <a>Arbitrary</a> for explanation) Used because genSharedSecret
--   already returns a list of EncShares, making the <a>replicateM</a>
--   unneeded.
unsafeMakeList :: Text -> IO [a] -> [a]

-- | Unsafely create pool of <tt>n</tt> random values to be picked (see
--   note in <a>Arbitrary</a> for explanation)
unsafeMakePool :: Text -> Int -> IO a -> [a]

-- | Make arbitrary <a>ByteString</a> of given length.
arbitrarySizedS :: Int -> Gen ByteString

-- | Make arbitrary <a>Lazy</a> of given length.
arbitrarySizedSL :: Int -> Gen ByteString

-- | Get something out of a quickcheck <a>Gen</a> without having to do IO
runGen :: Gen a -> a

-- | Specialized version of <a>mappend</a> for restricted to pair type.
mappendPair :: (Monoid a, Monoid b) => (a, b) -> (a, b) -> (a, b)

-- | Specialized version of <a>mconcat</a> (or <a>fold</a>) for restricting
--   type to list of pairs.
mconcatPair :: (Monoid a, Monoid b) => [(a, b)] -> (a, b)

-- | Concatenates two url part using regular slash <a>/</a>. E.g.
--   <tt>".<i>dir</i>" <a>//</a> "<i>file" = ".</i>dir/file"</tt>.
(<//>) :: String -> String -> String

-- | Convert (Reader s) to any (MonadState s)
readerToState :: MonadState s m => Reader s a -> m a

-- | A helper for simple error handling in executables
eitherPanic :: Show a => Text -> Either a b -> b

-- | This function performs checks at compile-time for different actions.
--   May slowdown implementation. To disable such checks (especially in
--   benchmarks) one should compile with: <tt>stack build --flag
--   cryptokami-sl:-asserts</tt>
inAssertMode :: Applicative m => m a -> m ()

-- | Remove elements which are in <tt>b</tt> from <tt>a</tt>
diffDoubleMap :: forall k1 k2 v. (Eq k1, Eq k2, Hashable k1, Hashable k2) => HashMap k1 (HashMap k2 v) -> HashMap k1 (HashMap k2 v) -> HashMap k1 (HashMap k2 v)
maybeThrow' :: (Mockable Throw m, Exception e) => e -> Maybe a -> m a
neZipWith3 :: (x -> y -> z -> q) -> NonEmpty x -> NonEmpty y -> NonEmpty z -> NonEmpty q

-- | Makes a span on the list, considering tail only. Predicate has list
--   head as first argument. Used to take non-null prefix that depends on
--   the first element.
spanSafe :: (a -> a -> Bool) -> NonEmpty a -> (NonEmpty a, [a])

-- | Make lenses for a data family instance.
makeLensesData :: Name -> Name -> DecsQ

-- | Lens for the head of <a>NonEmpty</a>.
--   
--   We can't use <tt>_head</tt> because it doesn't work for
--   <a>NonEmpty</a>:
--   <a>https://github.com/ekmett/lens/issues/636#issuecomment-213981096</a>.
--   Even if we could though, it wouldn't be a lens, only a traversal.
_neHead :: Lens' (NonEmpty a) a

-- | Lens for the tail of <a>NonEmpty</a>.
_neTail :: Lens' (NonEmpty a) [a]

-- | Lens for the last element of <a>NonEmpty</a>.
_neLast :: Lens' (NonEmpty a) a

-- | Remove all items from LRU, retaining maxSize property.
clearLRU :: Ord k => LRU k v -> LRU k v
eitherToVerRes :: Either Text a -> VerificationRes
clearMVar :: MonadIO m => MVar a -> m ()
forcePutMVar :: MonadIO m => MVar a -> a -> m ()

-- | Block until value in MVar satisfies given predicate. When value
--   satisfies, it is returned.
readMVarConditional :: (MonadIO m) => (x -> Bool) -> MVar x -> m x

-- | Read until value is equal to stored value comparing by some function.
readUntilEqualMVar :: (Eq a, MonadIO m) => (x -> a) -> MVar x -> a -> m x

-- | Block until value in TVar satisfies given predicate. When value
--   satisfies, it is returned.
readTVarConditional :: (MonadIO m) => (x -> Bool) -> TVar x -> m x

-- | Read until value is equal to stored value comparing by some function.
readUntilEqualTVar :: (Eq a, MonadIO m) => (x -> a) -> TVar x -> a -> m x
withReadLifted :: (MonadIO m, MonadMask m) => RWLock -> m a -> m a
withWriteLifted :: (MonadIO m, MonadMask m) => RWLock -> m a -> m a
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (System.Wlog.LoggerNameBox.LoggerNameBox m)
instance Control.Monad.Fail.MonadFail (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Resource.Internal.ResourceT m)


-- | Contains all Shared Seed Calculation algorithms implemented in our
--   prototype. For now only NIST Beacon and more smart algorithm known as
--   <i>Coin tossing with guaranteed output delivery</i>
--   (<tt>GodTossing</tt>).
module Pos.Ssc.SscAlgo

-- | Options for command line
data SscAlgo
GodTossingAlgo :: SscAlgo
NistBeaconAlgo :: SscAlgo
instance GHC.Classes.Eq Pos.Ssc.SscAlgo.SscAlgo
instance GHC.Show.Show Pos.Ssc.SscAlgo.SscAlgo

module Pos.Types.Block.Types

-- | Represents blockchain consisting of main blocks, i. e. blocks with
--   transactions and MPC messages.
data MainBlockchain ssc

-- | Header of generic main block.
type MainBlockHeader ssc = GenericBlockHeader (MainBlockchain ssc)

-- | Represents main block extra data
newtype MainExtraBodyData
MainExtraBodyData :: BlockBodyAttributes -> MainExtraBodyData
[_mebAttributes] :: MainExtraBodyData -> BlockBodyAttributes

-- | Represents main block header extra data
data MainExtraHeaderData
MainExtraHeaderData :: !BlockVersion -> !SoftwareVersion -> !BlockHeaderAttributes -> MainExtraHeaderData

-- | Version of block.
[_mehBlockVersion] :: MainExtraHeaderData -> !BlockVersion

-- | Software version.
[_mehSoftwareVersion] :: MainExtraHeaderData -> !SoftwareVersion

-- | Header attributes
[_mehAttributes] :: MainExtraHeaderData -> !BlockHeaderAttributes

-- | Represents main block header attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending header with new fields
--   via softfork.
type BlockHeaderAttributes = Attributes ()

-- | Represents main block body attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending block with new fields
--   via softfork.
type BlockBodyAttributes = Attributes ()

-- | Ssc w/ buildable blockchain
type BiSsc ssc = (Ssc ssc, Bi (GenericBlockHeader (GenesisBlockchain ssc)), Bi (GenericBlockHeader (MainBlockchain ssc)))

-- | Signature of the block. Can be either regular signature from the
--   issuer or delegated signature having a constraint on epoch indices (it
--   means the signature is valid only if block's slot id has epoch inside
--   the constrained interval).
data BlockSignature ssc
BlockSignature :: (Signature (MainToSign ssc)) -> BlockSignature ssc
BlockPSignatureEpoch :: (ProxySigLight (MainToSign ssc)) -> BlockSignature ssc
BlockPSignatureSimple :: (ProxySigHeavy (MainToSign ssc)) -> BlockSignature ssc

-- | Data to be signed in main block.
data MainToSign ssc
MainToSign :: !HeaderHash -> !(BodyProof (MainBlockchain ssc)) -> !SlotId -> !ChainDifficulty -> !MainExtraHeaderData -> MainToSign ssc
[_msHeaderHash] :: MainToSign ssc -> !HeaderHash
[_msBodyProof] :: MainToSign ssc -> !(BodyProof (MainBlockchain ssc))
[_msSlot] :: MainToSign ssc -> !SlotId
[_msChainDiff] :: MainToSign ssc -> !ChainDifficulty
[_msExtraHeader] :: MainToSign ssc -> !MainExtraHeaderData

-- | MainBlock is a block with transactions and MPC messages. It's the main
--   part of our consensus algorithm.
type MainBlock ssc = GenericBlock (MainBlockchain ssc)

-- | Represents blockchain consisting of genesis blocks. Genesis block
--   doesn't have any special payload and is not strictly necessary.
--   However, it is good idea to store list of leaders explicitly, because
--   calculating it may be expensive operation. For example, it is useful
--   for SPV-clients.
data GenesisBlockchain ssc

-- | Header of Genesis block.
type GenesisBlockHeader ssc = GenericBlockHeader (GenesisBlockchain ssc)

-- | Genesis block parametrized by <a>GenesisBlockchain</a>.
type GenesisBlock ssc = GenericBlock (GenesisBlockchain ssc)

-- | Represents genesis block header extra data
data GenesisExtraBodyData
GenesisExtraBodyData :: !GenesisBodyAttributes -> GenesisExtraBodyData

-- | Header attributes
[_gebAttributes] :: GenesisExtraBodyData -> !GenesisBodyAttributes

-- | Represents genesis block header attributes.
type GenesisBodyAttributes = Attributes ()

-- | Represents genesis block header extra data
data GenesisExtraHeaderData
GenesisExtraHeaderData :: !GenesisHeaderAttributes -> GenesisExtraHeaderData

-- | Header attributes
[_gehAttributes] :: GenesisExtraHeaderData -> !GenesisHeaderAttributes

-- | Represents genesis block header attributes.
type GenesisHeaderAttributes = Attributes ()

-- | Either header of ordinary main block or genesis block.
type BlockHeader ssc = Either (GenesisBlockHeader ssc) (MainBlockHeader ssc)

-- | Block.
type Block ssc = Either (GenesisBlock ssc) (MainBlock ssc)
type BiHeader ssc = Bi (BlockHeader ssc)
mehBlockVersion :: Lens' MainExtraHeaderData BlockVersion
mehSoftwareVersion :: Lens' MainExtraHeaderData SoftwareVersion
mehAttributes :: Lens' MainExtraHeaderData BlockHeaderAttributes
mebAttributes :: Iso' MainExtraBodyData BlockBodyAttributes
gehAttributes :: Iso' GenesisExtraHeaderData GenesisHeaderAttributes
gebAttributes :: Iso' GenesisExtraBodyData GenesisBodyAttributes
instance GHC.Generics.Generic Pos.Types.Block.Types.GenesisExtraBodyData
instance GHC.Show.Show Pos.Types.Block.Types.GenesisExtraBodyData
instance GHC.Classes.Eq Pos.Types.Block.Types.GenesisExtraBodyData
instance GHC.Generics.Generic Pos.Types.Block.Types.GenesisExtraHeaderData
instance GHC.Show.Show Pos.Types.Block.Types.GenesisExtraHeaderData
instance GHC.Classes.Eq Pos.Types.Block.Types.GenesisExtraHeaderData
instance Control.DeepSeq.NFData Pos.Types.Block.Types.MainExtraBodyData
instance GHC.Generics.Generic Pos.Types.Block.Types.MainExtraBodyData
instance GHC.Show.Show Pos.Types.Block.Types.MainExtraBodyData
instance GHC.Classes.Eq Pos.Types.Block.Types.MainExtraBodyData
instance GHC.Generics.Generic (Pos.Types.Block.Types.BlockSignature ssc)
instance GHC.Classes.Eq (Pos.Types.Block.Types.BlockSignature ssc)
instance GHC.Show.Show (Pos.Types.Block.Types.BlockSignature ssc)
instance GHC.Generics.Generic Pos.Types.Block.Types.MainExtraHeaderData
instance GHC.Show.Show Pos.Types.Block.Types.MainExtraHeaderData
instance GHC.Classes.Eq Pos.Types.Block.Types.MainExtraHeaderData
instance Control.DeepSeq.NFData (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc)) => Control.DeepSeq.NFData (Pos.Types.Block.Types.BlockSignature ssc)
instance Data.Text.Buildable.Buildable (Pos.Types.Block.Types.BlockSignature ssc)
instance Control.DeepSeq.NFData Pos.Types.Block.Types.MainExtraHeaderData
instance Data.Text.Buildable.Buildable Pos.Types.Block.Types.MainExtraHeaderData
instance Data.Text.Buildable.Buildable Pos.Types.Block.Types.MainExtraBodyData
instance Control.DeepSeq.NFData Pos.Types.Block.Types.GenesisExtraHeaderData
instance Data.Text.Buildable.Buildable Pos.Types.Block.Types.GenesisExtraHeaderData
instance Control.DeepSeq.NFData Pos.Types.Block.Types.GenesisExtraBodyData
instance Data.Text.Buildable.Buildable Pos.Types.Block.Types.GenesisExtraBodyData

module Pos.Security.CLI
data AttackType
AttackNoBlocks :: AttackType
AttackNoCommitments :: AttackType
data AttackTarget
NetworkAddressTarget :: NetworkAddress -> AttackTarget
[attNetworkAddr] :: AttackTarget -> NetworkAddress
PubKeyAddressTarget :: StakeholderId -> AttackTarget
[attPkAddr] :: AttackTarget -> StakeholderId
data NodeAttackedError
AttackNoBlocksTriggered :: NodeAttackedError
instance GHC.Show.Show Pos.Security.CLI.NodeAttackedError
instance GHC.Show.Show Pos.Security.CLI.AttackTarget
instance GHC.Classes.Eq Pos.Security.CLI.AttackTarget
instance GHC.Show.Show Pos.Security.CLI.AttackType
instance GHC.Classes.Eq Pos.Security.CLI.AttackType
instance GHC.Exception.Exception Pos.Security.CLI.NodeAttackedError


-- | <tt>Arbitrary</tt> unsafe instances for some types from <a>Types</a>.
module Pos.Types.Arbitrary.Unsafe
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Core.Types.SharedSeed
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Core.Types.EpochIndex
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Core.Types.LocalSlotIndex
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Core.Types.Coin
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Core.Types.Address
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Core.Types.SlotId
instance Pos.Util.Arbitrary.ArbitraryUnsafe Pos.Txp.Core.Types.TxOut


-- | <a>Arbitrary</a> instances for using in tests and benchmarks
module Pos.Crypto.Arbitrary
data SharedSecrets
SharedSecrets :: SecretSharingExtra -> Secret -> SecretProof -> [(EncShare, Share)] -> Threshold -> [VssPublicKey] -> Int -> SharedSecrets
[ssSecShare] :: SharedSecrets -> SecretSharingExtra
[ssSecret] :: SharedSecrets -> Secret
[ssSecProof] :: SharedSecrets -> SecretProof
[ssShares] :: SharedSecrets -> [(EncShare, Share)]
[ssThreshold] :: SharedSecrets -> Threshold
[ssVSSPKs] :: SharedSecrets -> [VssPublicKey]
[ssPos] :: SharedSecrets -> Int
instance GHC.Classes.Eq Pos.Crypto.Arbitrary.SharedSecrets
instance GHC.Show.Show Pos.Crypto.Arbitrary.SharedSecrets
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SignTag.SignTag
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.Signing.PublicKey
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.Signing.SecretKey
instance Pos.Util.Arbitrary.Nonrepeating Pos.Crypto.Signing.PublicKey
instance Pos.Util.Arbitrary.Nonrepeating Pos.Crypto.Signing.SecretKey
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.RedeemSigning.RedeemPublicKey
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.RedeemSigning.RedeemSecretKey
instance Pos.Util.Arbitrary.Nonrepeating Pos.Crypto.RedeemSigning.RedeemPublicKey
instance Pos.Util.Arbitrary.Nonrepeating Pos.Crypto.RedeemSigning.RedeemSecretKey
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SecretSharing.VssKeyPair
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SecretSharing.VssPublicKey
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.AsBinary Pos.Crypto.SecretSharing.VssPublicKey)
instance Pos.Util.Arbitrary.Nonrepeating Pos.Crypto.SecretSharing.VssKeyPair
instance Pos.Util.Arbitrary.Nonrepeating Pos.Crypto.SecretSharing.VssPublicKey
instance (Pos.Binary.Class.Bi a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Crypto.Signing.Signature a)
instance (Pos.Binary.Class.Bi a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Crypto.RedeemSigning.RedeemSignature a)
instance (Pos.Binary.Class.Bi a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Crypto.Signing.Signed a)
instance (Pos.Binary.Class.Bi w, Test.QuickCheck.Arbitrary.Arbitrary w) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Crypto.Signing.ProxyCert w)
instance (Pos.Binary.Class.Bi w, Test.QuickCheck.Arbitrary.Arbitrary w) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Crypto.Signing.ProxySecretKey w)
instance (Pos.Binary.Class.Bi w, Test.QuickCheck.Arbitrary.Arbitrary w, Pos.Binary.Class.Bi a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Crypto.Signing.ProxySignature w a)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SecretSharing.SecretSharingExtra
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.AsBinary Pos.Crypto.SecretSharing.SecretSharingExtra)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.AsBinary Pos.Crypto.SecretSharing.SecretProof)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SecretSharing.Secret
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.AsBinary Pos.Crypto.SecretSharing.Secret)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SecretSharing.SecretProof
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SecretSharing.EncShare
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.AsBinary Pos.Crypto.SecretSharing.EncShare)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SecretSharing.Share
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.AsBinary Pos.Crypto.SecretSharing.Share)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.Arbitrary.SharedSecrets
instance (Crypto.Hash.Types.HashAlgorithm algo, Pos.Binary.Class.Bi a) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Crypto.Hashing.AbstractHash algo a)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.SafeSigning.PassPhrase
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Crypto.HD.HDPassphrase


-- | A wrapper over Plutus (the scripting language used in transactions).
module Pos.Script

-- | A script for inclusion into a transaction.
data Script :: *
Script :: ScriptVersion -> LByteString -> Script

-- | Version
[scrVersion] :: Script -> ScriptVersion

-- | Serialized script
[scrScript] :: Script -> LByteString
type TxScriptError = String

-- | Validate a transaction, given a validator and a redeemer.
txScriptCheck :: Bi Script_v0 => TxSigData -> Script -> Script -> Either TxScriptError ()

-- | Parse a script intended to serve as a validator (or “lock”) in a
--   transaction output.
parseValidator :: Bi Script_v0 => Text -> Either String Script

-- | Parse a script intended to serve as a redeemer (or “proof”) in a
--   transaction input.
--   
--   Can be given an optional validator (e.g. if the redeemer uses
--   functions or types defined by the validator).
parseRedeemer :: Bi Script_v0 => Maybe Script -> Text -> Either String Script
stdlib :: Program
isKnownScriptVersion :: ScriptVersion -> Bool


-- | Some example scripts used in tests.
module Pos.Script.Examples
alwaysSuccessValidator :: Script
alwaysFailureValidator :: Script
idValidator :: Script
intValidator :: Script
goodIntRedeemer :: Script
badIntRedeemer :: Script
stdlibValidator :: Script
goodStdlibRedeemer :: Script
multisigValidator :: Int -> [PublicKey] -> Script
multisigRedeemer :: TxSigData -> [Maybe SafeSigner] -> Script
intValidatorWithBlah :: Script
goodIntRedeemerWithBlah :: Script

-- | Does N rounds of SHA3-256. Should be used with <a>idValidator</a>.
--   
--   Actually it does (N div 10) * 10 rounds. Unrolling the loop is done so
--   that more petrol would be spent on hashing and less – on substraction
--   and function calls.
shaStressRedeemer :: Int -> Script

-- | Checks a signature N times. Should be used with <a>idValidator</a>.
sigStressRedeemer :: Int -> Script

module Pos.Txp.Core

-- | A predicate for <a>TxOutAux</a> which checks whether given address
--   belongs to it.
addrBelongsTo :: TxOutAux -> Address -> Bool

-- | Construct <a>TxProof</a> which proves given <a>TxPayload</a>.
mkTxProof :: TxPayload -> TxProof

-- | Make a pair from <a>TxIn</a>.
txInToPair :: TxIn -> (TxId, Word32)

-- | Use this function if you need to know how a <a>TxOut</a> distributes
--   stake (e.g. for the purpose of running follow-the-satoshi).
txOutStake :: TxOutAux -> TxOutDistribution

-- | Convert <a>TxPayload</a> into a flat list of <a>TxAux</a>s.
flattenTxPayload :: TxPayload -> [TxAux]

-- | Does topological sort on things that contain transactions – e.g. can
--   be used both for sorting <tt>[Tx]</tt> and <tt>[(Tx, TxWitness)]</tt>.
--   
--   (Backwards dfs from every node with reverse visiting order recording.
--   Returns nothing on loop encountered. Return order is head-first.)
topsortTxs :: forall a. (Eq a) => (a -> WithHash Tx) -> [a] -> Maybe [a]

-- | Represents transaction identifier as <a>Hash</a> of <a>Tx</a>.
type TxId = Hash Tx

-- | A witness for a single input.
data TxInWitness
PkWitness :: !PublicKey -> !TxSig -> TxInWitness
[twKey] :: TxInWitness -> !PublicKey
[twSig] :: TxInWitness -> !TxSig
ScriptWitness :: !Script -> !Script -> TxInWitness
[twValidator] :: TxInWitness -> !Script
[twRedeemer] :: TxInWitness -> !Script
RedeemWitness :: !RedeemPublicKey -> !(RedeemSignature TxSigData) -> TxInWitness
[twRedeemKey] :: TxInWitness -> !RedeemPublicKey
[twRedeemSig] :: TxInWitness -> !(RedeemSignature TxSigData)
UnknownWitnessType :: !Word8 -> !ByteString -> TxInWitness

-- | A witness is a proof that a transaction is allowed to spend the funds
--   it spends (by providing signatures, redeeming scripts, etc). A
--   separate proof is provided for each input.
type TxWitness = Vector TxInWitness

-- | Distribution of "fake" stake that follow-the-satoshi would use for a
--   particular transaction output. Sum of coins in the list should be the
--   same as <a>txOutValue</a> of corresponding output.
type TxOutDistribution = [(StakeholderId, Coin)]

-- | Distribution of “fake” stake that follow-the-satoshi would use for a
--   particular transaction. Length of stored list must be same as length
--   of <a>_txOutputs</a> of corresponding transaction.
newtype TxDistribution
TxDistribution :: NonEmpty TxOutDistribution -> TxDistribution
[getTxDistribution] :: TxDistribution -> NonEmpty TxOutDistribution

-- | Data that is being signed when creating a TxSig.
data TxSigData
TxSigData :: !TxIn -> !(Hash (NonEmpty TxOut)) -> !(Hash TxDistribution) -> TxSigData

-- | Input that we're signing (i.e. our signature certifies that we own
--   funds referenced by this input)
[txSigInput] :: TxSigData -> !TxIn

-- | Outputs of the transaction (i.e. our signature certifies that we
--   actually want the funds to go to these particular outputs)
[txSigOutsHash] :: TxSigData -> !(Hash (NonEmpty TxOut))

-- | Distribution of the transaction
[txSigDistrHash] :: TxSigData -> !(Hash TxDistribution)

-- | <a>Signature</a> of addrId.
type TxSig = Signature TxSigData

-- | Transaction input.
data TxIn
TxIn :: !TxId -> !Word32 -> TxIn

-- | Which transaction's output is used
[txInHash] :: TxIn -> !TxId

-- | Index of the output in transaction's outputs
[txInIndex] :: TxIn -> !Word32

-- | Transaction output.
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[txOutAddress] :: TxOut -> !Address
[txOutValue] :: TxOut -> !Coin

-- | Transaction output and auxilary data corresponding to it. [CSL-366]
--   Add more data.
data TxOutAux
TxOutAux :: !TxOut -> !TxOutDistribution -> TxOutAux

-- | Tx output
[toaOut] :: TxOutAux -> !TxOut

-- | Stake distribution associated with output
[toaDistr] :: TxOutAux -> !TxOutDistribution

-- | Represents transaction attributes: map from 1-byte integer to
--   arbitrary-type value. To be used for extending transaction with new
--   fields via softfork.
type TxAttributes = Attributes ()

-- | Transaction.
--   
--   NB: transaction witnesses are stored separately.
data Tx
UnsafeTx :: !(NonEmpty TxIn) -> !(NonEmpty TxOut) -> !TxAttributes -> Tx

-- | Inputs of transaction.
[_txInputs] :: Tx -> !(NonEmpty TxIn)

-- | Outputs of transaction.
[_txOutputs] :: Tx -> !(NonEmpty TxOut)

-- | Attributes of transaction
[_txAttributes] :: Tx -> !TxAttributes

-- | Transaction + auxiliary data
type TxAux = (Tx, TxWitness, TxDistribution)

-- | Create valid Tx or fail. Verify inputs and outputs are non empty; have
--   enough coins.
mkTx :: MonadFail m => NonEmpty TxIn -> NonEmpty TxOut -> TxAttributes -> m Tx
txInputs :: Lens' Tx (NonEmpty TxIn)
txOutputs :: Lens' Tx (NonEmpty TxOut)
txAttributes :: Lens' Tx TxAttributes

-- | Specialized formatter for <a>Tx</a>.
txF :: Bi Tx => Format r (Tx -> r)

-- | Specialized formatter for <a>Tx</a> with auxiliary data
txaF :: Bi Tx => Format r (TxAux -> r)
data TxProof
TxProof :: !Word32 -> !(MerkleRoot Tx) -> !(Hash [TxWitness]) -> !(Hash [TxDistribution]) -> TxProof
[txpNumber] :: TxProof -> !Word32
[txpRoot] :: TxProof -> !(MerkleRoot Tx)
[txpWitnessesHash] :: TxProof -> !(Hash [TxWitness])
[txpDistributionsHash] :: TxProof -> !(Hash [TxDistribution])

-- | Payload of Txp component which is part of main block. Constructor is
--   unsafe, because it lets one create invalid payload, for example with
--   different number of transactions and witnesses.
data TxPayload
UnsafeTxPayload :: !(MerkleTree Tx) -> ![TxWitness] -> ![TxDistribution] -> TxPayload

-- | Transactions are the main payload.
[_txpTxs] :: TxPayload -> !(MerkleTree Tx)

-- | Transaction witnesses. Invariant: there are as many witnesses as there
--   are transactions in the block. This is checked during deserialisation.
--   We can't put them into the same Merkle tree with transactions, as the
--   whole point of segwit is to separate transactions and witnesses.
--   
--   TODO: should they be put into a separate Merkle tree or left as a
--   list?
[_txpWitnesses] :: TxPayload -> ![TxWitness]

-- | Distributions for P2SH addresses in transaction outputs. * length
--   mbTxAddrDistributions == length mbTxs * i-th element is <a>Just</a> if
--   at least one output of i-th transaction is P2SH * n-th element of i-th
--   element is <a>Just</a> if n-th output of i-th transaction is P2SH Ask
--   @neongreen if you don't understand wtf is going on. Basically, address
--   distributions are needed so that (potential) receivers of P2SH funds
--   would count as stakeholders.
[_txpDistributions] :: TxPayload -> ![TxDistribution]

-- | Smart constructor of <a>TxPayload</a> which can fail if some
--   invariants are violated.
--   
--   Currently there are two invariants: • number of txs must be same as
--   number of witnesses and number of distributions; • each distribution
--   must have the same number of elements as number of outputs in
--   corresponding transaction.
mkTxPayload :: (Bi Tx, MonadFail m) => [(Tx, TxWitness, TxDistribution)] -> m TxPayload
txpTxs :: Lens' TxPayload (MerkleTree Tx)
txpWitnesses :: Lens' TxPayload [TxWitness]
txpDistributions :: Lens' TxPayload [TxDistribution]

-- | Particular undo needed for transactions
type TxUndo = NonEmpty TxOutAux
type TxpUndo = [TxUndo]


-- | Txp settings which let customize Txp behavior.
module Pos.Txp.Settings
type TxpGlobalVerifyMode m = (WithLogger m, MonadDB m, MonadError ToilVerFailure m)
type TxpGlobalApplyMode m = (WithLogger m, MonadDB m, MonadSlots m)
type TxpGlobalRollbackMode m = (WithLogger m, MonadDB m)
type TxpBlock = Either (Some IsGenesisHeader) (Some IsMainHeader, TxPayload)
type TxpBlund = (TxpBlock, TxpUndo)
data TxpGlobalSettings
TxpGlobalSettings :: (forall m. TxpGlobalVerifyMode m => Bool -> OldestFirst NE TxpBlock -> m (OldestFirst NE TxpUndo)) -> (forall m. TxpGlobalApplyMode m => OldestFirst NE TxpBlund -> m SomeBatchOp) -> (forall m. TxpGlobalRollbackMode m => NewestFirst NE TxpBlund -> m SomeBatchOp) -> TxpGlobalSettings

-- | Verify a chain of payloads from blocks and return txp undos for each
--   payload.
--   
--   First argument determines whether it should be checked that all data
--   from transactions is known (script versions, attributes, addresses,
--   witnesses).
[tgsVerifyBlocks] :: TxpGlobalSettings -> forall m. TxpGlobalVerifyMode m => Bool -> OldestFirst NE TxpBlock -> m (OldestFirst NE TxpUndo)

-- | Apply chain of <i>definitely</i> valid blocks to Txp's GState.
[tgsApplyBlocks] :: TxpGlobalSettings -> forall m. TxpGlobalApplyMode m => OldestFirst NE TxpBlund -> m SomeBatchOp

-- | Rollback chain of blocks.
[tgsRollbackBlocks] :: TxpGlobalSettings -> forall m. TxpGlobalRollbackMode m => NewestFirst NE TxpBlund -> m SomeBatchOp

module Pos.Types.Block.Instances

-- | Proof of data stored in the body. Ensures immutability.

-- | Consensus data which can be used to check consensus properties.

-- | Body contains payload and other heavy data.

-- | Lens from <a>MainBlock</a> to <a>PublicKey</a>.
blockLeaderKey :: Lens' (MainBlock ssc) PublicKey

-- | Lens from <a>GenesisBlock</a> to <a>SlotLeaders</a>.
blockLeaders :: Lens' (GenesisBlock ssc) SlotLeaders

-- | Lens from <a>MainBlock</a> to <a>SscPayload</a>.
blockMpc :: Lens' (MainBlock ssc) (SscPayload ssc)

-- | Lens from <a>MainBlock</a> to <tt>Signature</tt>.
blockSignature :: Lens' (MainBlock ssc) (BlockSignature ssc)

-- | Lens from <a>MainBlock</a> to <a>SlotId</a>.
blockSlot :: Lens' (MainBlock ssc) SlotId

-- | Lens from <a>MainBlock</a> to <a>MerkleTree</a>.
blockTxs :: Lens' (MainBlock ssc) (MerkleTree Tx)

-- | Getter from <a>MainBlock</a> to a list of transactions together with
--   auxiliary data.
blockTxas :: Getter (MainBlock ssc) [TxAux]

-- | Lens from <a>MainBlock</a> to <a>ProxySKHeavy</a> list.
blockProxySKs :: Lens' (MainBlock ssc) [ProxySKHeavy]

-- | Lens for <a>ChainDifficulty</a> of <a>GenesisBlockchain</a> in
--   <a>ConsensusData</a>.
gcdDifficulty :: Lens' (ConsensusData (GenesisBlockchain ssc)) ChainDifficulty

-- | Lens for <a>EpochIndex</a> of <a>GenesisBlockchain</a> in
--   <a>ConsensusData</a>.
gcdEpoch :: Lens' (ConsensusData (GenesisBlockchain ssc)) EpochIndex

-- | Take <a>BlockHeader</a> from either <a>GenesisBlock</a> or
--   <a>MainBlock</a>.
getBlockHeader :: Block ssc -> BlockHeader ssc

-- | Lens from <a>MainBlockHeader</a> to <a>PublicKey</a>.
headerLeaderKey :: Lens' (MainBlockHeader ssc) PublicKey

-- | Lens from <a>MainBlockHeader</a> to <tt>Signature</tt>.
headerSignature :: Lens' (MainBlockHeader ssc) (BlockSignature ssc)

-- | Lens from <a>MainBlockHeader</a> to <a>SlotId</a>.
headerSlot :: Lens' (MainBlockHeader ssc) SlotId

-- | Lens for <a>SscPayload</a> in main block body.
mbMpc :: Lens' (Body (MainBlockchain ssc)) (SscPayload ssc)

-- | Lens for transaction payload in main block body.
mbTxPayload :: Lens' (Body (MainBlockchain ssc)) TxPayload

-- | Lens for transaction tree in main block body.
mbTxs :: Lens' (Body (MainBlockchain ssc)) (MerkleTree Tx)

-- | Lens for witness list in main block body.
mbWitnesses :: Lens' (Body (MainBlockchain ssc)) [TxWitness]

-- | Lens for ProxySKs in main block body.
mbProxySKs :: Lens' (Body (MainBlockchain ssc)) [ProxySKHeavy]

-- | Lens for <a>UpdatePayload</a> in main block body.
mbUpdatePayload :: Lens' (Body (MainBlockchain ssc)) UpdatePayload

-- | Lens for <a>SlotId</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdSlot :: Lens' (ConsensusData (MainBlockchain ssc)) SlotId

-- | Lens for <a>PublicKey</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdLeaderKey :: Lens' (ConsensusData (MainBlockchain ssc)) PublicKey

-- | Lens for <a>ChainDifficulty</a> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdDifficulty :: Lens' (ConsensusData (MainBlockchain ssc)) ChainDifficulty

-- | Lens for <tt>Signature</tt> of <a>MainBlockchain</a> in
--   <a>ConsensusData</a>.
mcdSignature :: Lens' (ConsensusData (MainBlockchain ssc)) (BlockSignature ssc)
blockHeader :: Getter (Block ssc) (BlockHeader ssc)

-- | This function is required because type inference fails in attempts to
--   hash only <tt>Right</tt> or <tt>Left</tt>.
blockHeaderHash :: BiHeader ssc => BlockHeader ssc -> HeaderHash
instance GHC.Generics.Generic (Pos.Core.Block.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Classes.Eq (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Show.Show (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Generics.Generic (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Generics.Generic (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance GHC.Classes.Eq (Pos.Core.Block.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Core.Block.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Core.Block.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Classes.Eq (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Show.Show (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Generics.Generic (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance GHC.Classes.Eq (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Core.Block.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance (GHC.Classes.Eq (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Types.Ssc ssc) => GHC.Classes.Eq (Pos.Core.Block.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance (Pos.Ssc.Class.Helpers.SscHelpersClass ssc, Pos.Binary.Class.Bi Pos.Txp.Core.Types.TxWitness, Pos.Binary.Class.Bi Pos.Update.Core.Types.UpdatePayload, Pos.Binary.Class.Bi Pos.Core.Types.EpochIndex) => Pos.Core.Block.Blockchain (Pos.Types.Block.Types.MainBlockchain ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Core.Block.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Core.Block.Blockchain (Pos.Types.Block.Types.GenesisBlockchain ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Core.Block.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => Control.DeepSeq.NFData (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.MainBlockHeader ssc)
instance (Pos.Binary.Class.Bi Pos.Update.Core.Types.UpdateProposal, Pos.Types.Block.Types.BiSsc ssc) => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.BlockHeader ssc)
instance Pos.Core.Class.HasEpochIndex Pos.Core.Types.SlotId
instance Pos.Core.Class.HasEpochIndex (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Core.Class.HasEpochIndex (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Core.Class.HasEpochIndex (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Core.Class.HasEpochIndex (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance (Pos.Core.Class.HasEpochIndex a, Pos.Core.Class.HasEpochIndex b) => Pos.Core.Class.HasEpochIndex (Data.Either.Either a b)
instance Pos.Core.Class.HasEpochOrSlot (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Core.Class.HasEpochOrSlot (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Core.Class.HasEpochOrSlot (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Core.Class.HasEpochOrSlot (Pos.Types.Block.Types.GenesisBlock ssc)
instance (Pos.Core.Class.HasEpochOrSlot a, Pos.Core.Class.HasEpochOrSlot b) => Pos.Core.Class.HasEpochOrSlot (Data.Either.Either a b)
instance Pos.Core.Class.HasHeaderHash Pos.Core.Types.HeaderHash
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.HasHeaderHash (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.HasHeaderHash (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.HasHeaderHash (Pos.Types.Block.Types.BlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.HasHeaderHash (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.HasHeaderHash (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.HasHeaderHash (Pos.Types.Block.Types.Block ssc)
instance Pos.Core.Class.HasDifficulty (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance Pos.Core.Class.HasDifficulty (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Pos.Core.Class.HasDifficulty (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Core.Class.HasDifficulty (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Core.Class.HasDifficulty (Pos.Types.Block.Types.BlockHeader ssc)
instance Pos.Core.Class.HasDifficulty (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Core.Class.HasDifficulty (Pos.Types.Block.Types.GenesisBlock ssc)
instance Pos.Core.Class.HasDifficulty (Pos.Types.Block.Types.Block ssc)
instance Pos.Core.Class.HasPrevBlock s => Pos.Core.Class.HasPrevBlock (s, z)
instance Pos.Core.Block.BHeaderHash b ~ Pos.Core.Types.HeaderHash => Pos.Core.Class.HasPrevBlock (Pos.Core.Block.GenericBlockHeader b)
instance Pos.Core.Block.BHeaderHash b ~ Pos.Core.Types.HeaderHash => Pos.Core.Class.HasPrevBlock (Pos.Core.Block.GenericBlock b)
instance (Pos.Core.Class.HasPrevBlock s, Pos.Core.Class.HasPrevBlock s') => Pos.Core.Class.HasPrevBlock (Data.Either.Either s s')
instance Pos.Core.Class.HasBlockVersion Pos.Types.Block.Types.MainExtraHeaderData
instance Pos.Core.Class.HasSoftwareVersion Pos.Types.Block.Types.MainExtraHeaderData
instance Pos.Core.Class.HasBlockVersion (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Core.Class.HasSoftwareVersion (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Core.Class.HasBlockVersion (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Core.Class.HasSoftwareVersion (Pos.Types.Block.Types.MainBlock ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.IsHeader (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.IsGenesisHeader (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.IsHeader (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.IsMainHeader (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Pos.Types.Block.Types.BiHeader ssc => Pos.Core.Class.IsHeader (Pos.Types.Block.Types.BlockHeader ssc)


-- | Functions related to blocks and headers.
module Pos.Types.Block

module Pos.CompileConfig
compileConfig :: CompileConfig

-- | Compile time configuration. See example in <i>constants.yaml</i> file.
data CompileConfig
CompileConfig :: !Int -> !Int -> !Word -> ![String] -> !Int -> !Word -> !Int -> !Int -> !Word64 -> !Word64 -> !Int -> !Word -> !Int -> !Int -> !Int -> !Int -> !Int -> CompileConfig

-- | Number of pre-generated keys
[ccGenesisN] :: CompileConfig -> !Int

-- | Estimated time for broadcasting messages
[ccNetworkDiameter] :: CompileConfig -> !Int

-- | Max number of transactions in Storage
[ccMaxLocalTxs] :: CompileConfig -> !Word

-- | List of default peers
[ccDefaultPeers] :: CompileConfig -> ![String]

-- | Number of slots to broadcast system time
[ccSysTimeBroadcastSlots] :: CompileConfig -> !Int

-- | Length of interval for sending MPC message
[ccMpcSendInterval] :: CompileConfig -> !Word

-- | Threshold of slots for malicious activity detection
[ccMdNoBlocksSlotThreshold] :: CompileConfig -> !Int

-- | Threshold of epochs for malicious activity detection
[ccMdNoCommitmentsEpochThreshold] :: CompileConfig -> !Int

-- | VSS certificates max timeout to live (number of epochs)
[ccVssMaxTTL] :: CompileConfig -> !Word64

-- | VSS certificates min timeout to live (number of epochs)
[ccVssMinTTL] :: CompileConfig -> !Word64

-- | Timeout for holding light psks confirmations
[ccLightDlgConfirmationTimeout] :: CompileConfig -> !Int

-- | We consider node as known if it was pinged at most 10 sec ago.
[ccEnhancedMessageTimeout] :: CompileConfig -> !Word

-- | Numbers of headers put in message in recovery mode.
[ccRecoveryHeadersMessage] :: CompileConfig -> !Int

-- | Interval we ignore cached messages in components that support caching
[ccMessageCacheTimeout] :: CompileConfig -> !Int

-- | Network connection timeout in milliseconds
[ccNetworkConnectionTimeout] :: CompileConfig -> !Int

-- | Block retrieval queue capacity
[ccBlockRetrievalQueueSize] :: CompileConfig -> !Int

-- | InvMsg propagation queue capacity
[ccPropagationQueueSize] :: CompileConfig -> !Int


-- | Constants used by algorithm. See paper for more details. Some
--   constants are parsed at compile-time (see <a>Type</a>). Others are
--   derived from those.
module Pos.Constants

-- | Estimated time needed to broadcast message from one node to all other
--   nodes. Also see <a>ccNetworkDiameter</a>.
networkDiameter :: Microsecond

-- | Length of shared seed.
sharedSeedLength :: Integral a => a

-- | Length of interval during which node should send her MPC message.
--   Relevant only for one SSC implementation. Also see
--   <a>ccMpcSendInterval</a>.
mpcSendInterval :: Microsecond

-- | See <a>ccGenesisN</a>.
genesisN :: Integral i => i

-- | Maximum amount of transactions we have in storage (i.e. we can accept
--   without putting them in block). There're next kind of storages in our
--   implementation:
--   
--   <ul>
--   <li>temporary storage of transactions</li>
--   <li>utxo map that corresponds to it</li>
--   <li>utxo of blocks in history</li>
--   </ul>
--   
--   This constant is size of first set. Also see <a>ccMaxLocalTxs</a>.
maxLocalTxs :: Integral i => i
networkConnectionTimeout :: Microsecond
blockRetrievalQueueSize :: Integral a => a
propagationQueueSize :: Integral a => a

-- | See <a>ccDefaultPeers</a>.
defaultPeers :: [DHTNode]

-- | <i>Time-lord</i> node announces system start time by broadcast. She
--   does it during first <a>ccSysTimeBroadcastSlots</a> slots.
sysTimeBroadcastSlots :: Integral i => i

-- | Max VSS certificate TTL (Ssc.GodTossing part)
vssMaxTTL :: Integral i => i

-- | Min VSS certificate TTL (Ssc.GodTossing part)
vssMinTTL :: Integral i => i

-- | Maximum amount of headers node can put into headers message while in
--   "after offline" or "recovery" mode. Should be more than
--   <a>blkSecurityParam</a>.
recoveryHeadersMessage :: (Integral a) => a

-- | Timeout for caching system. Components that use caching on messages
--   can use this timeout to invalidate caches.
messageCacheTimeout :: (Integral a) => a

-- | Amount of time we hold confirmations for light PSKs.
lightDlgConfirmationTimeout :: (Integral a) => a

-- | Number of slots used by malicious actions detection to check if we are
--   not receiving generated blocks.
mdNoBlocksSlotThreshold :: Integral i => i

-- | Number of epochs used by malicious actions detection to check if our
--   commitments are not included in blockchain.
mdNoCommitmentsEpochThreshold :: Integral i => i
appSystemTag :: SystemTag


-- | Pure functions related to blocks and headers.
module Pos.Block.Pure

-- | Difficulty of the Block, which is determined from header.
blockDifficultyIncrement :: Block ssc -> ChainDifficulty

-- | Difficulty of the BlockHeader. 0 for genesis block, 1 for main block.
headerDifficultyIncrement :: BlockHeader ssc -> ChainDifficulty

-- | Smart constructor for <a>GenericBlock</a>. Uses
--   <tt>mkGenericBlockHeader</tt>.
mkGenericBlock :: forall b. (HasHeaderHash (BBlockHeader b), Blockchain b, BHeaderHash b ~ HeaderHash) => Maybe (BBlockHeader b) -> Body b -> (BHeaderHash b -> BodyProof b -> ConsensusData b) -> ExtraHeaderData b -> ExtraBodyData b -> GenericBlock b

-- | Smart constructor for <a>GenericBlockHeader</a>.
mkGenericHeader :: forall b. (HasHeaderHash (BBlockHeader b), Blockchain b, BHeaderHash b ~ HeaderHash) => Maybe (BBlockHeader b) -> Body b -> (BHeaderHash b -> BodyProof b -> ConsensusData b) -> ExtraHeaderData b -> GenericBlockHeader b

-- | Smart constructor for <a>MainBlock</a>. Uses <a>mkMainHeader</a>.
mkMainBlock :: (BiSsc ssc, SscHelpersClass ssc, MonadFail m) => Maybe (BlockHeader ssc) -> SlotId -> SecretKey -> Maybe ProxySKEither -> Body (MainBlockchain ssc) -> MainExtraHeaderData -> MainExtraBodyData -> m (MainBlock ssc)
recreateMainBlock :: (BiSsc ssc, SscHelpersClass ssc, MonadFail m) => MainBlockHeader ssc -> Body (MainBlockchain ssc) -> MainExtraBodyData -> m (MainBlock ssc)

-- | Smart constructor for <a>MainBlockHeader</a>.
mkMainHeader :: (BiSsc ssc, SscHelpersClass ssc) => Maybe (BlockHeader ssc) -> SlotId -> SecretKey -> Maybe ProxySKEither -> Body (MainBlockchain ssc) -> MainExtraHeaderData -> MainBlockHeader ssc

-- | Smart constructor for <a>GenesisBlockHeader</a>. Uses
--   <a>mkGenericHeader</a>.
mkGenesisHeader :: BiSsc ssc => Maybe (BlockHeader ssc) -> EpochIndex -> Body (GenesisBlockchain ssc) -> GenesisBlockHeader ssc

-- | Smart constructor for <a>GenesisBlock</a>. Uses
--   <a>mkGenesisHeader</a>.
mkGenesisBlock :: BiSsc ssc => Maybe (BlockHeader ssc) -> EpochIndex -> SlotLeaders -> GenesisBlock ssc

-- | Predefined <a>Hash</a> of <a>GenesisBlock</a>.
genesisHash :: Hash a

-- | Parameters of Block static verification. Note: to check that block
--   references previous block and/or is referenced by next block, use
--   header verification (via vbpVerifyHeader).
data VerifyBlockParams ssc
VerifyBlockParams :: !(Maybe (VerifyHeaderParams ssc)) -> !Bool -> !Bool -> !Bool -> !(Maybe Byte) -> !Bool -> VerifyBlockParams ssc

-- | Verifies header accordingly to params (<a>verifyHeader</a>)
[vbpVerifyHeader] :: VerifyBlockParams ssc -> !(Maybe (VerifyHeaderParams ssc))

-- | Checks <tt>verifyGenesisBlock</tt> property.
[vbpVerifyGeneric] :: VerifyBlockParams ssc -> !Bool

-- | Verifies ssc payload with <a>sscVerifyPayload</a>.
[vbpVerifySsc] :: VerifyBlockParams ssc -> !Bool

-- | Check that's number of sks is limited (1000 for now).
[vbpVerifyProxySKs] :: VerifyBlockParams ssc -> !Bool

-- | Maximal block size.
[vbpMaxSize] :: VerifyBlockParams ssc -> !(Maybe Byte)

-- | Check that block has no unknown attributes.
[vbpVerifyNoUnknown] :: VerifyBlockParams ssc -> !Bool

-- | Extra data which may be used by verifyHeader function to do more
--   checks.
data VerifyHeaderParams ssc
VerifyHeaderParams :: !Bool -> !(Maybe (BlockHeader ssc)) -> !(Maybe (BlockHeader ssc)) -> !(Maybe SlotId) -> !(Maybe SlotLeaders) -> !(Maybe Byte) -> !Bool -> VerifyHeaderParams ssc
[vhpVerifyConsensus] :: VerifyHeaderParams ssc -> !Bool

-- | Nothing means that block is unknown, not genesis.
[vhpPrevHeader] :: VerifyHeaderParams ssc -> !(Maybe (BlockHeader ssc))
[vhpNextHeader] :: VerifyHeaderParams ssc -> !(Maybe (BlockHeader ssc))
[vhpCurrentSlot] :: VerifyHeaderParams ssc -> !(Maybe SlotId)
[vhpLeaders] :: VerifyHeaderParams ssc -> !(Maybe SlotLeaders)
[vhpMaxSize] :: VerifyHeaderParams ssc -> !(Maybe Byte)

-- | Check that header has no unknown attributes.
[vhpVerifyNoUnknown] :: VerifyHeaderParams ssc -> !Bool

-- | Check predicates defined by VerifyBlockParams. #verifyHeader
--   #verifyGenericBlock
verifyBlock :: (SscHelpersClass ssc, BiSsc ssc) => VerifyBlockParams ssc -> Block ssc -> VerificationRes

-- | Verify a sequence of blocks.
--   
--   foldl' is used here which eliminates laziness of triple. It doesn't
--   affect laziness of <a>VerificationRes</a> which is good because
--   laziness for this data type is crucial.
verifyBlocks :: forall ssc f t. (SscHelpersClass ssc, BiSsc ssc, t ~ OldestFirst f (Block ssc), NontrivialContainer t) => Maybe SlotId -> Bool -> BlockVersionData -> Maybe SlotLeaders -> OldestFirst f (Block ssc) -> VerificationRes

-- | Perform cheap checks of GenericBlock, which can be done using only
--   block itself. Checks which can be done using only header are ignored
--   here. It is assumed that they will be done separately.
verifyGenericBlock :: forall b. Blockchain b => GenericBlock b -> VerificationRes

-- | Check some predicates (determined by VerifyHeaderParams) about
--   BlockHeader. #verifyConsensusLocal
verifyHeader :: forall ssc. BiSsc ssc => VerifyHeaderParams ssc -> BlockHeader ssc -> VerificationRes

-- | Verifies a set of block headers.
verifyHeaders :: BiSsc ssc => Bool -> NewestFirst [] (BlockHeader ssc) -> VerificationRes
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Block.Pure.VerifyHeaderParams ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Block.Pure.VerifyHeaderParams ssc)
instance Data.Default.Class.Default (Pos.Block.Pure.VerifyHeaderParams ssc)
instance Data.Default.Class.Default (Pos.Block.Pure.VerifyBlockParams ssc)


-- | <a>Arbitrary</a> instances for core types for using in tests and
--   benchmarks
module Pos.Types.Arbitrary

-- | Ill-formed <a>Tx</a> with bad signatures.
newtype BadSigsTx
BadSigsTx :: NonEmpty ((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness) -> BadSigsTx
[getBadSigsTx] :: BadSigsTx -> NonEmpty ((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)

-- | This datatype has two coins that will always overflow when added. It
--   is used in tests to make sure addition raises the appropriate
--   exception when this happens.
newtype CoinPairOverflowSum
TwoCoinsSum :: (Coin, Coin) -> CoinPairOverflowSum
[get2CSum] :: CoinPairOverflowSum -> (Coin, Coin)

-- | This datatype has two coins that will always underflow when
--   subtracted. It is used in tests to make sure subtraction raises the
--   appropriate exception when this happens.
newtype CoinPairOverflowSub
TwoCoinsSub :: (Coin, Coin) -> CoinPairOverflowSub
[get2CSub] :: CoinPairOverflowSub -> (Coin, Coin)

-- | This datatype has a <a>Coin</a> and an <a>Integer</a> that will always
--   overflow when multiplied. It is used in tests to make sure
--   multiplication raises the appropriate exception when this happens.
newtype CoinPairOverflowMul
TwoCoinsM :: (Coin, Integer) -> CoinPairOverflowMul
[get2CMul] :: CoinPairOverflowMul -> (Coin, Integer)

-- | Another wrapper over <a>Double</a>. Its <a>Arbitrary</a> instance
--   guarantees the <a>Double</a> inside can always be safely turned into a
--   <tt>CoinPortion</tt>. Used in tests to ensure converting a valid
--   <a>Double</a> to/from <tt>CoinPortion</tt> works properly.
newtype DoubleInZeroToOneRange
DoubleInRange :: Double -> DoubleInZeroToOneRange
[getDoubleInRange] :: DoubleInZeroToOneRange -> Double

-- | This datatype has an Integer that will never overflow when turned into
--   a <a>Coin</a>. Useful for testing that conversion between valid
--   <a>Integer</a>s and <a>Coin</a>s works properly.
newtype IntegerToCoinNoOverflow
Integer :: Integer -> IntegerToCoinNoOverflow
[getInteger] :: IntegerToCoinNoOverflow -> Integer

-- | <a>IntegerToCoinOverflow</a> is a wrapped over <a>Integer</a>. Its
--   <a>Arbitrary</a> instance makes it so that these integers will always
--   overflow when converted into a <a>Coin</a>. Used in tests to make sure
--   an exception is raised when there is an attempt to turn an excessively
--   large <a>Integer</a> into a <a>Coin</a>.
newtype IntegerToCoinOverflow
LargeInteger :: Integer -> IntegerToCoinOverflow
[getLargeInteger] :: IntegerToCoinOverflow -> Integer

-- | Well-formed transaction <a>Tx</a>.
newtype GoodTx
GoodTx :: NonEmpty ((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness) -> GoodTx
[getGoodTx] :: GoodTx -> NonEmpty ((Tx, TxDistribution), TxIn, TxOutAux, TxInWitness)

-- | A wrapper over <a>Double</a>. Its <a>Arbitrary</a> instance ensures
--   the <a>Double</a> within can never be converted into a
--   <tt>CoinPortion</tt> without an exception being raised. Used in tests
--   to safeguard that converting an invalid <a>Double</a> to a
--   <tt>CoinPortion</tt> always raised an exception.
newtype LessThanZeroOrMoreThanOne
BadCoinPortion :: Double -> LessThanZeroOrMoreThanOne
[getDouble] :: LessThanZeroOrMoreThanOne -> Double

-- | This datatype has a <a>Coin</a> and an <a>Integer</a> that will always
--   overflow when multiplied. It is used to make sure coin multiplication
--   by an integer raises the appropriate exception when this happens.
newtype SafeCoinPairMul
CoinPairMul :: (Coin, Integer) -> SafeCoinPairMul
[getPairMul] :: SafeCoinPairMul -> (Coin, Integer)

-- | This datatype has two coins that will never overflow when added. It is
--   therefore safe to add them. Useful in tests to ensure adding two coins
--   whose sum is a valid <a>Coin</a> always works.
newtype SafeCoinPairSum
CoinPairSum :: (Coin, Coin) -> SafeCoinPairSum
[getPairSum] :: SafeCoinPairSum -> (Coin, Coin)

-- | This datatype has two coins that will never underflow when subtracted.
--   It is therefore safe to subtract them. Useful in tests to show that
--   two coins whose subtraction does not underflow always works.
newtype SafeCoinPairSub
CoinPairSub :: (Coin, Coin) -> SafeCoinPairSub
[getPairSub] :: SafeCoinPairSub -> (Coin, Coin)

-- | A wrapper over <a>Word64</a>. Its <a>Arbitrary</a> instance guarantees
--   the <a>Word64</a> inside can always be safely converted into
--   <tt>CoinPortion</tt>. Used in tests to ensure converting a valid
--   <a>Word64</a> to/from <tt>CoinPortion</tt> works properly.
newtype SafeWord
SafeWord :: Word64 -> SafeWord
[getSafeWord] :: SafeWord -> Word64
newtype SmallBadSigsTx
SmallBadSigsTx :: BadSigsTx -> SmallBadSigsTx
newtype SmallHashMap
SmallHashMap :: (HashMap PublicKey (HashMap PublicKey (AsBinary Share))) -> SmallHashMap
newtype SmallGoodTx
SmallGoodTx :: GoodTx -> SmallGoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679177080 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.FixedSizeInt a_6989586621679177080)
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679177072 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.SignedVarInt a_6989586621679177072)
instance Test.QuickCheck.Arbitrary.Arbitrary a_6989586621679177064 => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Binary.Class.UnsignedVarInt a_6989586621679177064)
instance GHC.Show.Show Pos.Types.Arbitrary.SmallHashMap
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Timestamp.Timestamp
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.SoftwareVersion
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Time.Units.Millisecond
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Time.Units.Microsecond
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallHashMap
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.BlockVersion
instance GHC.Show.Show Pos.Types.Arbitrary.SmallBadSigsTx
instance GHC.Show.Show Pos.Types.Arbitrary.BadSigsTx
instance GHC.Show.Show Pos.Types.Arbitrary.SmallGoodTx
instance GHC.Show.Show Pos.Types.Arbitrary.GoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.TxIn
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.Tx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.GoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallGoodTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.BadSigsTx
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SmallBadSigsTx
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Merkle.MerkleRoot Pos.Txp.Core.Types.Tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Merkle.MerkleTree Pos.Txp.Core.Types.Tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.TxProof
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.SharedSeed
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.ApplicationName
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.TxDistribution
instance GHC.Classes.Eq Pos.Types.Arbitrary.SafeWord
instance GHC.Show.Show Pos.Types.Arbitrary.SafeWord
instance GHC.Classes.Eq Pos.Types.Arbitrary.DoubleInZeroToOneRange
instance GHC.Show.Show Pos.Types.Arbitrary.DoubleInZeroToOneRange
instance GHC.Classes.Eq Pos.Types.Arbitrary.LessThanZeroOrMoreThanOne
instance GHC.Show.Show Pos.Types.Arbitrary.LessThanZeroOrMoreThanOne
instance GHC.Classes.Eq Pos.Types.Arbitrary.IntegerToCoinNoOverflow
instance GHC.Show.Show Pos.Types.Arbitrary.IntegerToCoinNoOverflow
instance GHC.Classes.Eq Pos.Types.Arbitrary.IntegerToCoinOverflow
instance GHC.Show.Show Pos.Types.Arbitrary.IntegerToCoinOverflow
instance GHC.Classes.Eq Pos.Types.Arbitrary.SafeCoinPairMul
instance GHC.Show.Show Pos.Types.Arbitrary.SafeCoinPairMul
instance GHC.Classes.Eq Pos.Types.Arbitrary.CoinPairOverflowMul
instance GHC.Show.Show Pos.Types.Arbitrary.CoinPairOverflowMul
instance GHC.Classes.Eq Pos.Types.Arbitrary.SafeCoinPairSub
instance GHC.Show.Show Pos.Types.Arbitrary.SafeCoinPairSub
instance GHC.Classes.Eq Pos.Types.Arbitrary.CoinPairOverflowSub
instance GHC.Show.Show Pos.Types.Arbitrary.CoinPairOverflowSub
instance GHC.Classes.Eq Pos.Types.Arbitrary.SafeCoinPairSum
instance GHC.Show.Show Pos.Types.Arbitrary.SafeCoinPairSum
instance GHC.Classes.Eq Pos.Types.Arbitrary.CoinPairOverflowSum
instance GHC.Show.Show Pos.Types.Arbitrary.CoinPairOverflowSum
instance System.Random.Random Pos.Core.Types.EpochIndex
instance System.Random.Random Pos.Core.Types.LocalSlotIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.TxSigData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.Coin
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.CoinPairOverflowSum
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SafeCoinPairSum
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.CoinPairOverflowSub
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SafeCoinPairSub
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.CoinPairOverflowMul
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SafeCoinPairMul
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.IntegerToCoinOverflow
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.IntegerToCoinNoOverflow
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.CoinPortion
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.LessThanZeroOrMoreThanOne
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.DoubleInZeroToOneRange
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Arbitrary.SafeWord
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.EpochIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.LocalSlotIndex
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.SlotId
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.EpochOrSlot
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.TxInWitness
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.TxOutAux
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.TxOut
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.ChainDifficulty
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.Script
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Core.Types.Address


-- | Arbitrary instances for Pos.Slotting types (infra package)
module Pos.Slotting.Arbitrary
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Slotting.Types.SlottingData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Slotting.Types.EpochSlottingData


-- | Re-export of Pos.Types.* + binary instances
module Pos.Types


-- | Interface to Blocks DB.
module Pos.DB.Block

-- | Get block with given hash from Block DB.
getBlock :: (SscHelpersClass ssc, MonadDB m) => HeaderHash -> m (Maybe (Block ssc))

-- | Returns header of block that was requested from Block DB.
getBlockHeader :: (SscHelpersClass ssc, MonadDB m) => HeaderHash -> m (Maybe (BlockHeader ssc))

-- | Get undo data for block with given hash from Block DB.
getUndo :: (MonadDB m) => HeaderHash -> m (Maybe Undo)

-- | Retrieves block and undo together.
getBlockWithUndo :: (SscHelpersClass ssc, MonadDB m) => HeaderHash -> m (Maybe (Block ssc, Undo))
deleteBlock :: (MonadDB m) => HeaderHash -> m ()

-- | Put given block, its metadata and Undo data into Block DB.
putBlock :: (SscHelpersClass ssc, MonadDB m) => Undo -> Block ssc -> m ()
prepareBlockDB :: forall ssc m. (SscHelpersClass ssc, MonadDB m) => GenesisBlock ssc -> m ()

-- | Load blunds starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadBlundsWhile :: (SscHelpersClass ssc, MonadDB m) => (Block ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (Blund ssc))

-- | Load blunds which have depth less than given.
loadBlundsByDepth :: (SscHelpersClass ssc, MonadDB m) => Word -> HeaderHash -> m (NewestFirst [] (Blund ssc))

-- | Load blocks starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadBlocksWhile :: (SscHelpersClass ssc, MonadDB m) => (Block ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (Block ssc))

-- | Load headers starting from block with header hash equal to given hash
--   and while <tt>predicate</tt> is true.
loadHeadersWhile :: (SscHelpersClass ssc, MonadDB m) => (BlockHeader ssc -> Bool) -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))

-- | Load headers which have depth less than given.
loadHeadersByDepth :: (SscHelpersClass ssc, MonadDB m) => Word -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))

-- | Load headers which have depth less than given and match some
--   criterion.
loadHeadersByDepthWhile :: (SscHelpersClass ssc, MonadDB m) => (BlockHeader ssc -> Bool) -> Word -> HeaderHash -> m (NewestFirst [] (BlockHeader ssc))


-- | Everything related to <i>follow-the-satoshi</i> procedure.
module Pos.Lrc.FtsPure

-- | Choose several random stakeholders (specifically, their amount is
--   currently hardcoded in <a>epochSlots</a>).
--   
--   The probability that a stakeholder will be chosen is proportional to
--   the number of coins this stakeholder holds. The same stakeholder can
--   be picked more than once.
--   
--   How the algorithm works: we sort all unspent outputs in a
--   deterministic way (lexicographically) and have an ordered sequence of
--   pairs <tt>(StakeholderId, Coin)</tt>. Then we choose several random
--   <tt>i</tt>s between 1 and amount of satoshi in the system; to find
--   owner of <tt>i</tt>th coin we find the lowest x such that sum of all
--   coins in this list up to <tt>i</tt>th is not less than <tt>i</tt> (and
--   then <tt>x</tt>th address is the owner).
--   
--   With P2SH addresses, we don't know who is going to end up with funds
--   sent to them. Therefore, P2SH addresses can contain
--   <tt>addrDestination</tt> which specifies which addresses should count
--   as “owning” funds for the purposes of follow-the-satoshi.
followTheSatoshi :: SharedSeed -> Utxo -> NonEmpty StakeholderId

-- | Select slot leaders for an entire epoch, randomly. The probability
--   that a stakeholder will be chosen as a slot leader is directly
--   proportional to his stake. The same stakeholder can be chosen for
--   multiple slots within an epoch.
--   
--   As input, the <i>follow-the-satoshi</i> procedure requires:
--   
--   <ul>
--   <li>a source of randomness (PRNG seed).</li>
--   <li>the list of balances, i.e. (StakeholderId, Coin) pairs, ordered by
--   stakeholder identifiers. Since the list can be quite large, we access
--   it using <a>MonadIterator</a> to achieve streaming.</li>
--   <li>the total amount of coins in the system. We could compute it as
--   the sum of balances (indeed, it is assumed to be equal to that value),
--   but computing it here would break streaming, so we take it as a
--   separate input.</li>
--   </ul>
--   
--   As an output, we have one slot leader per slot: a list of stakeholder
--   identifiers of length <a>epochSlots</a>.
--   
--   The algorithm here is a bit tricky to ensure that it runs in
--   O(balances) time. First we generate a random coin index for each slot,
--   so we get a list like this:
--   
--   <pre>
--   <a>assignToSlots</a> coinIndices =
--     [ (LocalSlotIndex 0, CoinIndex 5)
--     , (LocalSlotIndex 1, CoinIndex 327)
--     , (LocalSlotIndex 2, CoinIndex 61)
--     , ...
--     , (LocalSlotIndex k, CoinIndex 205) ]
--   
--     where k = epochSlots - 1
--   </pre>
--   
--   The coin indices are random numbers in range
--   <tt>[0..totalCoins-1]</tt>.
--   
--   Then we want to find the owners of the coins with the generated
--   indices. In the example above, the stakeholder that owns the 5th coin
--   will be the leader of the 0th slot in the epoch, the owner of the
--   327th coin will be the leader of the 1st slot, and so on.
--   
--   Recall that we have a sorted list of balances. We could use it to
--   compute a table of coin indices, for example:
--   
--   <pre>
--   StakeholderId | Coin (amount) | Coin indices (inclusive range)
--   --------------+---------------+-----------------------------
--             aaa | 200           |   [0..199]
--             bbb | 50            | [200..249]
--             ccc | 80            | [250..329]
--             ... | ...           | ...
--             zzz | 500           | [totalCoins - 1 - 500 .. totalCoins - 1]
--   </pre>
--   
--   A solution with complexity O(slots * balances) would be
--   straightforward: just lookup a leader for each slot in the table -
--   whenever the selected coin is in the coin index range, we have a
--   match.
--   
--   However, we can be a bit smarter and get an asymptotic improvement.
--   First, let's sort the generated coin indices:
--   
--   <pre>
--   [ (LocalSlotIndex 0, CoinIndex 5)
--   , (LocalSlotIndex 2, CoinIndex 61)
--   , (LocalSlotIndex k, CoinIndex 205)
--   , (LocalSlotIndex 1, CoinIndex 327)
--   , ... ]
--   </pre>
--   
--   Since they are zipped together with their slot indices, we can restore
--   the original ordering later (using <a>arrangeBySlots</a>).
--   
--   Now that selected coin indices and stakeholder coin index ranges are
--   both sorted, we can walk through them in one pass! To do that, we
--   <a>traverse</a> the list of selected coin indices. As we do that, we
--   monadically iterate through the table of balances, storing current
--   stakeholder identifier and coin index range in a state (see
--   <a>FtsState</a>).
--   
--   Let's take a look at the intermediate states during execution:
--   
--   <ol>
--   <li>Initialize the state as <tt>StakeholderId=aaa,
--   CoinRange=[0..199]</tt>.</li>
--   <li>Select the next coin, <tt>LocalSlotIndex=0, CoinIndex=5</tt>.</li>
--   <li><tt>CoinIndex</tt> falls within the <tt>CoinRange</tt>, yield slot
--   leader <tt>LocalSlotIndex=0, StakeholderId=aaa</tt>.</li>
--   <li>Select the next coin, <tt>LocalSlotIndex=2,
--   CoinIndex=61</tt>.</li>
--   <li><tt>CoinIndex</tt> falls within the <tt>CoinRange</tt>, yield slot
--   leader <tt>LocalSlotIndex=2, StakeholderId=aaa</tt>.</li>
--   <li>Select the next coin, <tt>LocalSlotIndex=k,
--   CoinIndex=205</tt>.</li>
--   <li><tt>CoinIndex</tt> does not fall within the <tt>CoinRange</tt>.
--   Update the state to <tt>StakeholderId=bbb,
--   CoinRange=[200..249]</tt>.</li>
--   <li><tt>CoinIndex</tt> falls within the <tt>CoinRange</tt>, yield slot
--   leader <tt>LocalSlotIndex=k, StakeholderId=bbb</tt>.</li>
--   <li>Select the next coin, <tt>LocalSlotIndex=1,
--   CoinIndex=327</tt>.</li>
--   <li><tt>CoinIndex</tt> does not fall within the <tt>CoinRange</tt>.
--   Update the state to...</li>
--   </ol>
--   
--   Eventually, we end up with a list of slot leaders:
--   
--   <pre>
--   [ (LocalSlotIndex 0, StakeholderId aaa)
--   , (LocalSlotIndex 2, StakeholderId aaa)
--   , (LocalSlotIndex k, StakeholderId bbb)
--   , (LocalSlotIndex 1, StakeholderId ccc)
--   , ... ]
--   </pre>
--   
--   and we're done. One thing to notice is that <a>MonadIterator</a>
--   provides us with a balance - the amount of coins a stakeholder has -
--   but not with a coin index range. So in order to have access to coin
--   range, we have to accumulate (by summation) those balances - this way
--   we get upper bounds. There's no need to calculate lower bounds, since
--   every lower bound is equal to the upper bound of the previous
--   stakeholder plus 1, and we transition to next coin only when the
--   current coin index exceeds the upper bound. Since coin indices are
--   sorted, whenever we transition to the next coin, its index bona fide
--   exceeds the previous upper bound (and thus it's more or equal to the
--   current lower bound).
followTheSatoshiM :: MonadIterator (StakeholderId, Coin) m => SharedSeed -> Coin -> m SlotLeaders


-- | Blockchain genesis. Not to be confused with genesis block in epoch.
--   Blockchain genesis means genesis values which are hardcoded in advance
--   (before system starts doing anything). Genesis block in epoch exists
--   in every epoch and it's not known in advance.
module Pos.Genesis

-- | Stake distribution in genesis block. FlatStakes is a flat
--   distribution, i. e. each node has the same amount of coins.
--   BitcoinStakes is a Bitcoin mining pool-style ditribution.
data StakeDistribution
FlatStakes :: !Word -> !Coin -> StakeDistribution
BitcoinStakes :: !Word -> !Coin -> StakeDistribution
RichPoorStakes :: !Word -> !Coin -> !Word -> !Coin -> StakeDistribution
[sdRichmen] :: StakeDistribution -> !Word
[sdRichStake] :: StakeDistribution -> !Coin
[sdPoor] :: StakeDistribution -> !Word
[sdPoorStake] :: StakeDistribution -> !Coin
ExponentialStakes :: StakeDistribution
ExplicitStakes :: !(HashMap Address (Coin, TxOutDistribution)) -> StakeDistribution
CombinedStakes :: StakeDistribution -> StakeDistribution -> StakeDistribution

-- | Hardcoded genesis data
data GenesisData
GenesisData :: [Address] -> StakeDistribution -> VssCertificatesMap -> !(HashMap StakeholderId Coin) -> GenesisData
[gdAddresses] :: GenesisData -> [Address]
[gdDistribution] :: GenesisData -> StakeDistribution
[gdVssCertificates] :: GenesisData -> VssCertificatesMap
[gdBootstrapBalances] :: GenesisData -> !(HashMap StakeholderId Coin)
getTotalStake :: StakeDistribution -> Coin

-- | Fetch pre-generated genesis data from <i>genesis.bin</i> in compile
--   time Doesn't use TH with lift because it's difficult to provide
--   <tt>Lift</tt> instance to <a>GenesisData</a>
compileGenData :: GenesisData
genesisStakeDistribution :: StakeDistribution

-- | Genesis <a>Utxo</a>.
genesisUtxo :: StakeDistribution -> Utxo
genesisDelegation :: HashMap StakeholderId [StakeholderId]

-- | List of addresses in genesis. See <tt>genesisPublicKeys</tt>.
genesisAddresses :: [Address]

-- | Seed that will be used for the 0th epoch. We must hardcode a seed
--   because we need to somehow determine leaders for the first ever epoch
--   (stakes are hardcoded as well so we can run FTS on those stakes using
--   this seed).
genesisSeed :: SharedSeed
genesisBalances :: HashMap StakeholderId Coin

-- | List of pairs from <a>SecretKey</a> with corresponding
--   <a>PublicKey</a>.
genesisDevKeyPairs :: [(PublicKey, SecretKey)]

-- | List of <a>PublicKey</a>s in genesis.
genesisDevPublicKeys :: [PublicKey]

-- | List of <a>SecretKey</a>s in genesis.
genesisDevSecretKeys :: [SecretKey]

-- | Leaders of genesis. See <a>followTheSatoshi</a>.
genesisLeaders :: Utxo -> SlotLeaders
instance Data.Default.Class.Default Pos.Genesis.Types.StakeDistribution


-- | Reexports of Pos.Binary.* classes
module Pos.Binary


-- | Module providing restoring from backup phrase functionality
module Pos.Util.BackupPhrase

-- | Datatype to contain a valid backup phrase
data BackupPhrase

-- | Make backup phrase from list
mkBackupPhrase12 :: [Text] -> BackupPhrase

-- | Make backup phrase from list
mkBackupPhrase9 :: [Text] -> BackupPhrase

-- | Number of words in backup phrase
backupPhraseWordsNum :: Int
bpToList :: BackupPhrase -> [Text]
toSeed :: BackupPhrase -> Either Text ByteString
keysFromPhrase :: BackupPhrase -> Either Text (SecretKey, VssKeyPair)
safeKeysFromPhrase :: PassPhrase -> BackupPhrase -> Either Text (EncryptedSecretKey, VssKeyPair)
instance GHC.Generics.Generic Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Classes.Eq Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Show.Show Pos.Util.BackupPhrase.BackupPhrase
instance Data.Text.Buildable.Buildable Pos.Util.BackupPhrase.BackupPhrase
instance GHC.Read.Read Pos.Util.BackupPhrase.BackupPhrase


-- | GState DB stores whole global state, i. e. result of application of
--   all blocks up to <i>tip</i>.
module Pos.DB.GState

-- | Tries to retrieve next block using current one (given a block/header).
resolveForwardLink :: (HasHeaderHash a, MonadDB m) => a -> m (Maybe HeaderHash)

-- | Check if given hash representing block is in main chain.
isBlockInMainChain :: (HasHeaderHash a, MonadDB m) => a -> m Bool
data BlockExtraOp

-- | Adds or overwrites forward link
AddForwardLink :: HeaderHash -> HeaderHash -> BlockExtraOp

-- | Removes forward link
RemoveForwardLink :: HeaderHash -> BlockExtraOp

-- | Enables or disables "in main chain" status of the block
SetInMainChain :: Bool -> HeaderHash -> BlockExtraOp

-- | Returns headers loaded up.
loadHeadersUpWhile :: (SscHelpersClass ssc, MonadDB m, HasHeaderHash a) => a -> (BlockHeader ssc -> Int -> Bool) -> m (OldestFirst [] (BlockHeader ssc))

-- | Returns blocks loaded up.
loadBlocksUpWhile :: (SscHelpersClass ssc, MonadDB m, HasHeaderHash a) => a -> (Block ssc -> Int -> Bool) -> m (OldestFirst [] (Block ssc))
prepareGStateBlockExtra :: MonadDB m => HeaderHash -> m ()

-- | Put missing initial data into GState DB.
prepareGStateDB :: forall ssc m. (WithNodeContext ssc m, MonadDB m) => HeaderHash -> m ()

-- | Check that GState DB is consistent.
sanityCheckGStateDB :: forall m. (MonadDB m, MonadMask m, WithLogger m) => m ()
usingGStateSnapshot :: (MonadDB m, MonadMask m) => m a -> m a

-- | Retrieves certificate by issuer address (hash of public key) if
--   present.
getPSKByIssuerAddressHash :: MonadDB m => StakeholderId -> m (Maybe ProxySKHeavy)

-- | Retrieves certificate by issuer public key if present.
getPSKByIssuer :: MonadDB m => PublicKey -> m (Maybe ProxySKHeavy)
isIssuerByAddressHash :: MonadDB m => StakeholderId -> m Bool
data DelegationOp

-- | Adds PSK. Overwrites if present.
AddPSK :: !ProxySKHeavy -> DelegationOp

-- | Removes PSK by issuer PK.
DelPSK :: !PublicKey -> DelegationOp
runPskIterator :: forall m a. MonadDB m => DBnIterator PskIter a -> m a
runPskMapIterator :: forall v m a. MonadDB m => DBnMapIterator PskIter v a -> (IterType PskIter -> v) -> m a
data BalancesOp
PutFtsSum :: !Coin -> BalancesOp
PutFtsStake :: !StakeholderId -> !Coin -> BalancesOp
isBootstrapEra :: MonadDB m => m Bool
getEffectiveTotalStake :: MonadDB m => m Coin
getEffectiveStake :: MonadDB m => StakeholderId -> m (Maybe Coin)
genesisFakeTotalStake :: Coin
prepareGStateBalances :: forall m. MonadDB m => Utxo -> m ()
data BalanceIter :: *

-- | Run iterator over effective balances.
runBalanceIterator :: forall m a. MonadDB m => (forall iter. (MonadIterator (IterType BalanceIter) iter, MonadDB iter) => iter a) -> m a

-- | Run map iterator over effective balances.
runBalanceMapIterator :: forall v m a. MonadDB m => (forall iter. (MonadIterator v iter, MonadDB iter) => iter a) -> (IterType BalanceIter -> v) -> m a
runBalanceIterBootstrap :: forall m a. Monad m => ListHolderT (IterType BalanceIter) m a -> m a
sanityCheckBalances :: (MonadMask m, MonadDB m, WithLogger m) => m ()
getTxOutFromDB :: (MonadIO m, MonadThrow m) => TxIn -> DB -> m (Maybe TxOutAux)
getTxOut :: MonadDB m => TxIn -> m (Maybe TxOutAux)
data UtxoOp
DelTxIn :: !TxIn -> UtxoOp
AddTxOut :: !TxIn -> !TxOutAux -> UtxoOp
prepareGStateUtxo :: MonadDB m => Utxo -> m ()
data UtxoIter
runUtxoIterator :: forall i m a. (MonadDB m, DBIteratorClass i, IterKey i ~ TxIn, IterValue i ~ TxOutAux) => DBnIterator i a -> m a
runUtxoMapIterator :: forall i v m a. (MonadDB m, DBIteratorClass i, IterKey i ~ TxIn, IterValue i ~ TxOutAux) => DBnMapIterator i v a -> (IterType i -> v) -> m a
getFilteredUtxo :: MonadDB m => Address -> m Utxo

-- | Get full utxo. Use with care – the utxo can be very big (hundreds of
--   megabytes).
getAllPotentiallyHugeUtxo :: MonadDB m => m Utxo
sanityCheckUtxo :: (MonadDB m, WithLogger m) => Coin -> m ()


-- | Higher-level DB functionality.
module Pos.DB.DB

-- | Open all DBs stored on disk.
openNodeDBs :: (MonadIO m) => Bool -> FilePath -> m NodeDBs

-- | Initialize DBs if necessary.
initNodeDBs :: forall ssc m. (SscHelpersClass ssc, WithNodeContext ssc m, MonadDB m) => m ()

-- | Get current tip from GState DB.
getTip :: MonadDB m => m HeaderHash

-- | Get block corresponding to tip.
getTipBlock :: (SscHelpersClass ssc, MonadDB m) => m (Block ssc)

-- | Get BlockHeader corresponding to tip.
getTipBlockHeader :: (SscHelpersClass ssc, MonadDB m) => m (BlockHeader ssc)

-- | Load blunds from BlockDB starting from tip and while the
--   <tt>condition</tt> is true.
loadBlundsFromTipWhile :: (SscHelpersClass ssc, MonadDB m) => (Block ssc -> Bool) -> m (NewestFirst [] (Blund ssc))

-- | Load blunds from BlockDB starting from tip which have depth less than
--   given.
loadBlundsFromTipByDepth :: (SscHelpersClass ssc, MonadDB m) => Word -> m (NewestFirst [] (Blund ssc))
sanityCheckDB :: (MonadMask m, MonadDB m, WithLogger m) => m ()
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Catch.MonadThrow m, Control.Monad.Catch.MonadCatch m) => Pos.DB.Class.MonadDBCore (Pos.DB.Holder.DBHolder m)


-- | Monadic represantion of something that has <tt>json</tt> journaled log
--   of operations.
module Pos.Util.JsonLog

-- | Json log event.
data JLEvent
JLCreatedBlock :: JLBlock -> JLEvent
JLAdoptedBlock :: BlockId -> JLEvent
JLTpsStat :: Int -> JLEvent

-- | Json log of one block with corresponding <a>BlockId</a>.
data JLBlock
JLBlock :: BlockId -> BlockId -> [TxId] -> JLSlotId -> JLBlock
[jlHash] :: JLBlock -> BlockId
[jlPrevBlock] :: JLBlock -> BlockId
[jlTxs] :: JLBlock -> [TxId]
[jlSlot] :: JLBlock -> JLSlotId

-- | <a>JLEvent</a> with <tt>Timestamp</tt> -- corresponding time of this
--   event.
data JLTimedEvent
JLTimedEvent :: Integer -> JLEvent -> JLTimedEvent
[jlTimestamp] :: JLTimedEvent -> Integer
[jlEvent] :: JLTimedEvent -> JLEvent

-- | Return event of created block.
jlCreatedBlock :: BiSsc ssc => Block ssc -> JLEvent

-- | Returns event of created <a>Block</a>.
jlAdoptedBlock :: Ssc ssc => Block ssc -> JLEvent

-- | Monad for things that can log Json log events.
class Monad m => MonadJL m where jlLog = lift . jlLog
jlLog :: MonadJL m => JLEvent -> m ()
jlLog :: (MonadJL m, MonadTrans t, MonadJL m', t m' ~ m) => JLEvent -> m ()

-- | Append event into log by given <a>FilePath</a>.
appendJL :: (MonadIO m) => FilePath -> JLEvent -> m ()

-- | Get <a>SlotId</a> from <a>JLSlotId</a>.
fromJLSlotId :: JLSlotId -> SlotId
instance Data.Aeson.Types.ToJSON.ToJSON Pos.Util.JsonLog.JLTimedEvent
instance Data.Aeson.Types.FromJSON.FromJSON Pos.Util.JsonLog.JLTimedEvent
instance (Pos.Util.JsonLog.MonadJL m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Pos.Util.JsonLog.MonadJL (t m)
instance Data.Aeson.Types.ToJSON.ToJSON Pos.Util.JsonLog.JLEvent
instance Data.Aeson.Types.FromJSON.FromJSON Pos.Util.JsonLog.JLEvent
instance Data.Aeson.Types.ToJSON.ToJSON Pos.Util.JsonLog.JLBlock
instance Data.Aeson.Types.FromJSON.FromJSON Pos.Util.JsonLog.JLBlock
instance GHC.Show.Show Pos.Util.JsonLog.JLTimedEvent
instance GHC.Show.Show Pos.Util.JsonLog.JLEvent
instance GHC.Show.Show Pos.Util.JsonLog.JLBlock

module Pos.Context

-- | Class for something that has <a>NodeContext</a> inside.
type WithNodeContext ssc = MonadReader ContextTag (NodeContext ssc)
getNodeContext :: WithNodeContext ssc m => m (NodeContext ssc)

-- | NodeContext contains runtime context of node.
data NodeContext ssc
NodeContext :: !(Maybe (MVar FilePath)) -> !(SscNodeContext ssc) -> !UpdateContext -> !LrcContext -> !(MVar HeaderHash) -> !(TVar UserSecret) -> !(TBQueue (NodeId, NewestFirst NE (BlockHeader ssc))) -> !(TMVar (NodeId, BlockHeader ssc)) -> !(TMVar (BlockHeader ssc)) -> !RelayInvQueue -> !LoggerConfig -> !NodeParams -> !(TVar Bool) -> !(TBQueue ()) -> !(Maybe (MVar ())) -> !UTCTime -> !(TVar (Maybe (BlockHeader ssc))) -> !TxpGlobalSettings -> !SlotLeaders -> !(TVar (Set NodeId)) -> NodeContext ssc
[ncJLFile] :: NodeContext ssc -> !(Maybe (MVar FilePath))
[ncSscContext] :: NodeContext ssc -> !(SscNodeContext ssc)

-- | Context needed for the update system
[ncUpdateContext] :: NodeContext ssc -> !UpdateContext

-- | Context needed for LRC
[ncLrcContext] :: NodeContext ssc -> !LrcContext

-- | Semaphore which manages access to block application. Stored hash is a
--   hash of last applied block.
[ncBlkSemaphore] :: NodeContext ssc -> !(MVar HeaderHash)

-- | Secret keys (and path to file) which are used to send transactions
[ncUserSecret] :: NodeContext ssc -> !(TVar UserSecret)

-- | Concurrent queue that holds block headers that are to be downloaded.
[ncBlockRetrievalQueue] :: NodeContext ssc -> !(TBQueue (NodeId, NewestFirst NE (BlockHeader ssc)))

-- | In case of recovery mode this variable holds the latest header hash we
--   know about, and the node we're talking to, so we can do chained block
--   requests. Invariant: this mvar is full iff we're more than
--   <tt>recoveryHeadersMessage</tt> blocks deep relatively to some valid
--   header and we're downloading blocks. Every time we get block that's
--   more difficult than this one, we overwrite. Every time we process some
--   blocks and fail or see that we've downloaded this header, we clean
--   mvar.
[ncRecoveryHeader] :: NodeContext ssc -> !(TMVar (NodeId, BlockHeader ssc))

-- | Header of the last block that was downloaded in retrieving queue. Is
--   needed to show smooth prorgess on the frontend.
[ncProgressHeader] :: NodeContext ssc -> !(TMVar (BlockHeader ssc))

-- | Queue is used in Relay framework, it stores inv messages for earlier
--   received data.
[ncInvPropagationQueue] :: NodeContext ssc -> !RelayInvQueue

-- | Logger config, as taken/read from CLI.
[ncLoggerConfig] :: NodeContext ssc -> !LoggerConfig

-- | Params node is launched with
[ncNodeParams] :: NodeContext ssc -> !NodeParams

-- | If this flag is <a>True</a>, then workers should stop.
[ncShutdownFlag] :: NodeContext ssc -> !(TVar Bool)

-- | A queue which is used to count how many workers have successfully
--   terminated.
[ncShutdownNotifyQueue] :: NodeContext ssc -> !(TBQueue ())

-- | Exclusive lock for sending messages to other nodes (if Nothing, no
--   lock used).
[ncSendLock] :: NodeContext ssc -> !(Maybe (MVar ()))

-- | Time when node was started (<a>NodeContext</a> initialized).
[ncStartTime] :: NodeContext ssc -> !UTCTime

-- | Header of last known block, generated by network (announcement of
--   which reached us). Should be use only for informational purposes
--   (status in Daedalus). It's easy to falsify this value.
[ncLastKnownHeader] :: NodeContext ssc -> !(TVar (Maybe (BlockHeader ssc)))

-- | Settings for global Txp.
[ncTxpGlobalSettings] :: NodeContext ssc -> !TxpGlobalSettings

-- | Leaders of the first epoch
[ncGenesisLeaders] :: NodeContext ssc -> !SlotLeaders

-- | Set of peers that we're connected to.
[ncConnectedPeers] :: NodeContext ssc -> !(TVar (Set NodeId))

-- | Generate <a>PublicKey</a> from <tt>SecretKey</tt> of
--   <a>NodeContext</a>.
ncPublicKey :: NodeContext ssc -> PublicKey

-- | Generate <a>Address</a> from <tt>SecretKey</tt> of <a>NodeContext</a>
ncPubKeyAddress :: NodeContext ssc -> Address
ncGenesisUtxo :: NodeContext ssc -> Utxo
ncSystemStart :: NodeContext __ -> Timestamp

-- | Contains algorithm specific &amp; storage parameters for Node.
data NodeParams
NodeParams :: !FilePath -> !Bool -> !Timestamp -> !SecretKey -> !UserSecret -> !BaseParams -> !Utxo -> !(Maybe FilePath) -> ![AttackType] -> ![AttackTarget] -> !Bool -> ![Text] -> !UpdateParams -> !Bool -> NodeParams

-- | Path to node's database.
[npDbPathM] :: NodeParams -> !FilePath

-- | <tt>True</tt> if data-base should be rebuilt
[npRebuildDb] :: NodeParams -> !Bool

-- | System start
[npSystemStart] :: NodeParams -> !Timestamp

-- | Primary secret key of node
[npSecretKey] :: NodeParams -> !SecretKey

-- | All node secret keys
[npUserSecret] :: NodeParams -> !UserSecret

-- | See <a>BaseParams</a>
[npBaseParams] :: NodeParams -> !BaseParams

-- | predefined custom utxo
[npCustomUtxo] :: NodeParams -> !Utxo
[npJLFile] :: NodeParams -> !(Maybe FilePath)

-- | List of attack types used by malicious emulation
[npAttackTypes] :: NodeParams -> ![AttackType]

-- | List of targets to attack by malicious emulation
[npAttackTargets] :: NodeParams -> ![AttackTarget]

-- | Whether to propagate txs, ssc data, blocks to neighbors
[npPropagation] :: NodeParams -> !Bool

-- | List of report server URLs
[npReportServers] :: NodeParams -> ![Text]

-- | Params for update system
[npUpdateParams] :: NodeParams -> !UpdateParams
[npUseNTP] :: NodeParams -> !Bool

-- | Contains basic &amp; networking parameters for running node.
data BaseParams
BaseParams :: !LoggingParams -> BaseParams

-- | Logger parameters
[bpLoggingParams] :: BaseParams -> !LoggingParams
genesisUtxoM :: (Functor m, WithNodeContext ssc m) => m Utxo
genesisLeadersM :: (Functor m, WithNodeContext ssc m) => m SlotLeaders
putBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => HeaderHash -> m ()
readBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => m HeaderHash
takeBlkSemaphore :: (MonadIO m, WithNodeContext ssc m) => m HeaderHash

-- | Block until LRC data is available for given epoch.
waitLrc :: (MonadIO m, HasContext LrcContext m) => EpochIndex -> m ()
lrcActionOnEpoch :: (MonadIO m, HasContext LrcContext m, MonadThrow m) => EpochIndex -> (EpochIndex -> m (Maybe a)) -> m a
lrcActionOnEpochReason :: (MonadIO m, HasContext LrcContext m, MonadThrow m) => EpochIndex -> Text -> (EpochIndex -> m (Maybe a)) -> m a

-- | Returns node uptime based on current time and <a>ncStartTime</a>.
getUptime :: (MonadIO m, WithNodeContext ssc m) => m Microsecond

-- | Returns if <a>ncRecoveryHeader</a> is <a>Just</a> which is equivalent
--   to “we're doing recovery”.
recoveryInProgress :: (MonadIO m, WithNodeContext ssc m) => m Bool

-- | Wrapper for monadic action which brings <a>NodeContext</a>.
type ContextHolder ssc = ContextHolder' (ContextHolderTrans ssc)

-- | Run <a>ContextHolder</a> action.
runContextHolder :: NodeContext ssc -> ContextHolder ssc m a -> m a

module Pos.Security.Util
shouldIgnoreAddress :: NodeContext ssc -> NetworkAddress -> Bool
shouldIgnorePkAddress :: NodeContext ssc -> StakeholderId -> Bool

module Pos.Ssc.Extra
type MonadSscMem ssc = MonadReader SscMemTag (SscState ssc)
askSscMem :: MonadSscMem ssc m => m (SscState ssc)
data SscMemTag
type SscHolder ssc = ReaderT SscMemTag (SscState ssc)
mkSscHolderState :: forall ssc m. (WithLogger m, HasContext LrcContext m, SscGStateClass ssc, SscLocalDataClass ssc, MonadDB m, MonadSlots m) => m (SscState ssc)
mkStateAndRunSscHolder :: forall ssc m a. (WithLogger m, HasContext LrcContext m, SscGStateClass ssc, SscLocalDataClass ssc, MonadDB m, MonadSlots m) => SscHolder ssc m a -> m a

-- | Run <a>SscHolder</a> reading GState from DB (restoring from blocks)
--   and using default (uninitialized) local state.
runSscHolder :: forall ssc m a. SscState ssc -> SscHolder ssc m a -> m a
ignoreSscHolder :: SscHolder ssc m a -> m a

-- | Run something that reads <a>SscLocalData</a> in <a>MonadSscMem</a>.
--   <a>MonadIO</a> is also needed to use stm.
sscRunLocalQuery :: forall ssc m a. (MonadSscMem ssc m, MonadIO m) => ReaderT (SscLocalData ssc) m a -> m a

-- | Run STM transaction which modifies <a>SscLocalData</a> and also can
--   log.
sscRunLocalSTM :: forall ssc m a. (MonadSscMem ssc m, MonadIO m, WithLogger m) => StateT (SscLocalData ssc) (NamedPureLogger STM) a -> m a

-- | Run something that reads <a>SscGlobalState</a> in <a>MonadSscMem</a>.
--   <a>MonadIO</a> is also needed to use stm.
sscRunGlobalQuery :: forall ssc m a. (MonadSscMem ssc m, MonadIO m) => ReaderT (SscGlobalState ssc) m a -> m a

-- | Calculate <a>SharedSeed</a> for given epoch.
sscCalculateSeed :: forall ssc m. (MonadSscMem ssc m, MonadDB m, SscGStateClass ssc, HasContext LrcContext m, MonadIO m, WithLogger m) => EpochIndex -> m (Either (SscSeedError ssc) SharedSeed)

-- | Get <a>SscPayload</a> for inclusion into main block with given
--   <a>SlotId</a>.
sscGetLocalPayload :: forall ssc m. (MonadIO m, MonadSscMem ssc m, SscLocalDataClass ssc, WithLogger m) => SlotId -> m (SscPayload ssc)

-- | Update local data to be valid for current global state. This function
--   is assumed to be called after applying block and before releasing lock
--   on block application.
sscNormalize :: forall ssc m. (MonadDB m, MonadSscMem ssc m, SscLocalDataClass ssc, HasContext LrcContext m, SscHelpersClass ssc, WithLogger m) => m ()

-- | Reset local data to empty state. This function can be used when we
--   detect that something is really bad. In this case it makes sense to
--   remove all local data to be sure it's valid.
sscResetLocal :: forall ssc m. (MonadDB m, MonadSscMem ssc m, SscLocalDataClass ssc, MonadSlots m) => m ()

-- | Apply sequence of definitely valid blocks. Global state which is
--   result of application of these blocks can be optionally passed as
--   argument (it can be calculated in advance using
--   <a>sscVerifyBlocks</a>).
sscApplyBlocks :: forall ssc m. SscGlobalApplyMode ssc m => OldestFirst NE (Block ssc) -> Maybe (SscGlobalState ssc) -> m [SomeBatchOp]

-- | Rollback application of given sequence of blocks. Bad things can
--   happen if these blocks haven't been applied before.
sscRollbackBlocks :: forall ssc m. SscGlobalApplyMode ssc m => NewestFirst NE (Block ssc) -> m [SomeBatchOp]

-- | Verify sequence of blocks and return global state which corresponds to
--   application of given blocks. If blocks are invalid, this function will
--   return it using <a>MonadError</a> type class. All blocks must be from
--   the same epoch.
sscVerifyBlocks :: forall ssc m. SscGlobalVerifyMode ssc m => OldestFirst NE (Block ssc) -> m (SscGlobalState ssc)

-- | Whole state of SSC. Stored only in-memory by design.
data SscState ssc
SscState :: !(TVar (SscGlobalState ssc)) -> !(TVar (SscLocalData ssc)) -> SscState ssc
[sscGlobal] :: SscState ssc -> !(TVar (SscGlobalState ssc))
[sscLocal] :: SscState ssc -> !(TVar (SscLocalData ssc))

module Pos.Statistics

-- | Log count statistic event.
statlogCountEvent :: (MonadStats m, StatLabel l, EntryType l ~ CountStat) => l -> Word64 -> m ()

-- | Log value statistic event.
statlogValueEvent :: (MonadStats m, StatLabel l, EntryType l ~ ValueStat) => l -> Double -> m ()

-- | <a>MonadStats</a> is a monad which has methods for stats collecting
class Monad m => MonadStats m where statLog label = lift . statLog label resetStat = lift . resetStat logStatM label action = action >>= statLog label
statLog :: (MonadStats m, StatLabel l) => l -> EntryType l -> m ()
resetStat :: (MonadStats m, StatLabel l) => l -> m ()
statLog :: (MonadStats m, MonadTrans t, MonadStats m', t m' ~ m, StatLabel l) => l -> EntryType l -> m ()
resetStat :: (MonadStats m, MonadTrans t, MonadStats m', t m' ~ m, StatLabel l) => l -> m ()

-- | Default convenience method, which we can override (to truly do nothing
--   in <a>NoStatsT</a>, for example)
logStatM :: (MonadStats m, StatLabel l) => l -> m (EntryType l) -> m ()

-- | Stats wrapper for collecting statistics without collecting it.
type NoStatsT = TaggedTrans NoStatsTag IdentityT
getNoStatsT :: NoStatsT m a -> m a

-- | Statistics wrapper around some monadic action to collect statistics
--   during execution of this action. Used in benchmarks.
type StatsT = ReaderT StatsMap
runStatsT :: MonadIO m => StatsT m a -> m a
runStatsT' :: StatsMap -> StatsT m a -> m a
getStatsMap :: Monad m => StatsT m StatsMap

-- | Stat entry is a simple counter or a structure for aggregating
--   statistical data about real value
type StatEntry e = (Monoid e, FullySerializable e)

-- | <a>StatLabel</a> is some datatype which determines a single stat
class (FullySerializable l, Buildable l, Hashable l, StatEntry (EntryType l)) => StatLabel l where type EntryType l :: * where {
    type family EntryType l :: *;
}
labelName :: StatLabel l => Proxy l -> Text
toJLEvent :: StatLabel l => l -> EntryType l -> JLEvent

-- | Counter for specified statistics.
newtype CountStat
CountStat :: Word64 -> CountStat
[getCounter] :: CountStat -> Word64

-- | Value for specified collected statistic.
data ValueStat
ValueStat :: !Word64 -> !Double -> !Double -> !Double -> ValueStat
[valueCount] :: ValueStat -> !Word64
[valueMin] :: ValueStat -> !Double
[valueMax] :: ValueStat -> !Double
[valueSum] :: ValueStat -> !Double

-- | Singleton data type to represent collected statistics about processes
--   <tt>Tx'</tt>s.
data StatProcessTx
StatProcessTx :: StatProcessTx


-- | <a>WorkMode</a> constraint. It is widely used in almost every our
--   code. Simple alias for bunch of useful constraints. This module also
--   contains new monads to extend functional capabilities inside do-block.
module Pos.WorkMode

-- | Bunch of constraints to perform work for real world distributed
--   system.
type WorkMode ssc m = (MinWorkMode m, MonadMask m, MonadSlots m, MonadDB m, MonadDBLimits m, MonadTxpMem TxpExtra_TMP m, MonadRelayMem m, MonadDelegation m, MonadSscMem ssc m, MonadReportingMem m, SscGStateClass ssc, SscLocalDataClass ssc, SscHelpersClass ssc, WithNodeContext ssc m, HasContext LrcContext m, HasContext UpdateContext m, HasContext NodeParams m, HasContext UpdateParams m, MonadStats m, MonadJL m, WithPeerState m, MonadShutdownMem m, MonadDiscovery m)

-- | More relaxed version of <a>WorkMode</a>.
type MinWorkMode m = (WithLogger m, MonadMockable m, MonadIO m, WithPeerState m)
type TxpExtra_TMP = ()

-- | RawRealMode + kademlia. Used in wallet too.
type RawRealModeK ssc = DiscoveryKademliaT (RawRealMode ssc)

-- | ProductionMode is an instance of WorkMode which is used
--   (unsurprisingly) in production.
type ProductionMode ssc = NoStatsT $ RawRealModeK ssc

-- | RawRealMode is a basis for <a>WorkMode</a>s used to really run system.
type RawRealMode ssc = PeerStateHolder (DelegationT (TxpHolder TxpExtra_TMP (SscHolder ssc (NtpSlotting (SlottingHolder (DBHolder (ContextHolder ssc (LoggerNameBox Production))))))))

-- | ServiceMode is the mode in which support nodes work.
type ServiceMode = PeerStateHolder (LoggerNameBox Production)

-- | StatsMode is used for remote benchmarking.
type StatsMode ssc = StatsT $ RawRealModeK ssc

-- | Fixed peer discovery without stats.
type StaticMode ssc = NoStatsT $ DiscoveryConstT (RawRealMode ssc)

module Pos.Security.Class
class Ssc ssc => SecurityWorkersClass ssc
securityWorkers :: (SecurityWorkersClass ssc, WorkMode ssc m) => Tagged ssc ([WorkerSpec m], OutSpecs)

module Pos.Security


-- | Re-exports of Pos.Ssc.Class.* modules.
module Pos.Ssc.Class
class Ssc ssc => SscHelpersClass ssc
sscVerifyPayload :: SscHelpersClass ssc => Tagged ssc (Either EpochIndex (MainBlockHeader ssc) -> SscPayload ssc -> Either (SscVerifyError ssc) ())

-- | Class for defining listeners in DHT <tt>SSC</tt> implementation.
class Ssc ssc => SscListenersClass ssc
sscListeners :: (SscListenersClass ssc, WorkMode ssc m) => m (Tagged ssc ([ListenerSpec m], OutSpecs))
sscStubListeners :: (SscListenersClass ssc, WithLogger m) => Tagged ssc ([ListenerSpec m], OutSpecs)
type LocalQuery ssc a = forall m. (MonadReader (SscLocalData ssc) m, WithLogger m) => m a
type LocalUpdate ssc a = forall m. (MonadState (SscLocalData ssc) m, WithLogger m) => m a

-- | This type class abstracts local data used for SSC. Local means that it
--   is not stored in blocks.
class Ssc ssc => SscLocalDataClass ssc

-- | Get local payload to be put into main block and for given
--   <a>SlotId</a>. If payload for given <a>SlotId</a> can't be
--   constructed, empty payload can be returned.
sscGetLocalPayloadQ :: SscLocalDataClass ssc => SlotId -> LocalQuery ssc (SscPayload ssc)

-- | Make <a>SscLocalData</a> valid for given epoch, richmen and global
--   state. of best known chain).
sscNormalizeU :: SscLocalDataClass ssc => EpochIndex -> RichmenStake -> SscGlobalState ssc -> LocalUpdate ssc ()

-- | Create new (empty) local data. We are using this function instead of
--   <tt>Default</tt> class, because it gives more flexibility. For
--   instance, one can read something from DB or get current slot.
sscNewLocalData :: (SscLocalDataClass ssc, MonadSlots m, MonadDB m) => m (SscLocalData ssc)
class Ssc ssc => SscGStateClass ssc

-- | Load global state from DB by recreating it from recent blocks.
sscLoadGlobalState :: (SscGStateClass ssc, MonadDB m, WithLogger m) => m (SscGlobalState ssc)

-- | Dump global state to DB.
sscGlobalStateToBatch :: SscGStateClass ssc => SscGlobalState ssc -> Tagged ssc [SomeBatchOp]

-- | Rollback application of blocks.
sscRollbackU :: SscGStateClass ssc => NewestFirst NE (Block ssc) -> SscGlobalUpdate ssc ()

-- | Verify SSC-related part of given blocks with respect to current GState
--   and apply them on success. Blocks must be from the same epoch.
sscVerifyAndApplyBlocks :: SscGStateClass ssc => RichmenStake -> OldestFirst NE (Block ssc) -> SscVerifier ssc ()

-- | Calculate <a>SharedSeed</a> for given epoch using
--   <a>SscGlobalState</a>.
sscCalculateSeedQ :: SscGStateClass ssc => EpochIndex -> RichmenStake -> SscGlobalQuery ssc (Either (SscSeedError ssc) SharedSeed)
type SscGlobalQuery ssc a = forall m. (MonadReader (SscGlobalState ssc) m, WithLogger m) => m a
type SscGlobalUpdate ssc a = forall m. (MonadState (SscGlobalState ssc) m, WithLogger m) => m a
type SscVerifier ssc a = forall m. SscVerifyMode ssc m => m a

-- | Main Shared Seed Calculation type class. Stores all needed type
--   parameters for general implementation of SSC.
class (Typeable ssc, Typeable (SscPayload ssc), Typeable (SscProof ssc), Typeable (SscSeedError ssc), Eq (SscProof ssc), Eq (SscGlobalState ssc), Show (SscProof ssc), Show (SscPayload ssc), Buildable (SscPayload ssc), Buildable (SscSeedError ssc), Buildable (SscVerifyError ssc), Buildable (SscGlobalState ssc), Bi (SscProof ssc), Bi (SscPayload ssc), NFData (SscPayload ssc), NFData (SscProof ssc)) => Ssc ssc where type SscLocalData ssc type SscPayload ssc type SscGlobalState ssc type SscProof ssc type SscSeedError ssc type SscNodeContext ssc type SscParams ssc type SscVerifyError ssc where {
    type family SscLocalData ssc;
    type family SscPayload ssc;
    type family SscGlobalState ssc;
    type family SscProof ssc;
    type family SscSeedError ssc;
    type family SscNodeContext ssc;
    type family SscParams ssc;
    type family SscVerifyError ssc;
}

-- | Create proof (for inclusion into block header) from payload
mkSscProof :: Ssc ssc => Tagged ssc (SscPayload ssc -> SscProof ssc)

-- | Create SscNodeContext
sscCreateNodeContext :: (Ssc ssc, MonadIO m) => Tagged ssc (SscParams ssc -> m (SscNodeContext ssc))

-- | Class for <tt>SSC</tt> workers.
class Ssc ssc => SscWorkersClass ssc

-- | All workers specific to SSC.
sscWorkers :: (SscWorkersClass ssc, WorkMode ssc m) => Tagged ssc ([WorkerSpec m], OutSpecs)
sscLrcConsumers :: (SscWorkersClass ssc, WorkMode ssc m, MonadDBCore m) => Tagged ssc [LrcConsumer m]
type SscConstraint ssc = (Ssc ssc, SscListenersClass ssc, SscLocalDataClass ssc, SscHelpersClass ssc, SscGStateClass ssc, SscWorkersClass ssc, SecurityWorkersClass ssc)
type WorkModeSsc ssc = (SscLocalDataClass ssc, SscHelpersClass ssc)


-- | Simplified NIST beacon implementation of SSC.
module Pos.Ssc.NistBeacon

-- | Data type tag for Nist Beacon implementation of Shared Seed
--   Calculation.
data SscNistBeacon
instance GHC.Generics.Generic Pos.Ssc.NistBeacon.SscNistBeacon
instance GHC.Show.Show Pos.Ssc.NistBeacon.SscNistBeacon
instance GHC.Classes.Eq Pos.Ssc.NistBeacon.SscNistBeacon
instance Data.Text.Buildable.Buildable ()
instance Pos.Ssc.Class.Types.Ssc Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Helpers.SscHelpersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Workers.SscWorkersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Listeners.SscListenersClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.LocalData.SscLocalDataClass Pos.Ssc.NistBeacon.SscNistBeacon
instance Pos.Ssc.Class.Storage.SscGStateClass Pos.Ssc.NistBeacon.SscNistBeacon

module Pos.Ssc.Arbitrary
newtype SscPayloadDependsOnSlot ssc
SscPayloadDependsOnSlot :: (SlotId -> Gen (SscPayload ssc)) -> SscPayloadDependsOnSlot ssc
[genPayloadDependsOnSlot] :: SscPayloadDependsOnSlot ssc -> SlotId -> Gen (SscPayload ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Arbitrary.SscPayloadDependsOnSlot Pos.Ssc.NistBeacon.SscNistBeacon)

module Pos.Update.Arbitrary

module Pos.Genesis.Arbitrary
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Genesis.Types.GenesisData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Genesis.Types.StakeDistribution


-- | Re-exports of GodTossing modules.
--   
--   GodTossing is a coin tossing with guaranteed output delivery. Nodes
--   exchange commitments, openings, and shares, and in the end arrive at a
--   shared seed.
--   
--   See <a>https://eprint.iacr.org/2015/889.pdf</a> (“A Provably Secure
--   Proof-of-Stake Blockchain Protocol”), section 4 for more details.
module Pos.Ssc.GodTossing

-- | Wrapper over '(Commitment, Opening)'. Creates an invalid pair of a
--   Commitment and an Opening w.r.t. <tt>verifyOpening</tt>.
data BadCommAndOpening
BadCommAndOpening :: (Commitment, Opening) -> BadCommAndOpening
[getBadCAndO] :: BadCommAndOpening -> (Commitment, Opening)

-- | Wrapper over <a>Commitment</a>. Creates an invalid Commitment w.r.t.
--   <tt>verifyCommitment</tt>.
newtype BadCommitment
BadComm :: Commitment -> BadCommitment
[getBadComm] :: BadCommitment -> Commitment

-- | Wrapper over <a>SignedCommitment</a>. Creates an invalid
--   SignedCommitment w.r.t. <tt>verifyCommitmentSignature</tt>.
newtype BadSignedCommitment
BadSignedComm :: SignedCommitment -> BadSignedCommitment
[getBadSignedC] :: BadSignedCommitment -> SignedCommitment

-- | Pair of <a>Commitment</a> and <a>Opening</a>.
data CommitmentOpening
CommitmentOpening :: !Commitment -> !Opening -> CommitmentOpening
[coCommitment] :: CommitmentOpening -> !Commitment
[coOpening] :: CommitmentOpening -> !Opening

-- | Generate securely random SharedSeed.
genCommitmentAndOpening :: (MonadFail m, MonadIO m) => Threshold -> NonEmpty (AsBinary VssPublicKey) -> m (Commitment, Opening)
isCommitmentId :: SlotId -> Bool
isCommitmentIdx :: LocalSlotIndex -> Bool
isOpeningId :: SlotId -> Bool
isOpeningIdx :: LocalSlotIndex -> Bool
isSharesId :: SlotId -> Bool
isSharesIdx :: LocalSlotIndex -> Bool

-- | Make signed commitment from commitment and epoch index using secret
--   key.
mkSignedCommitment :: Bi Commitment => SecretKey -> EpochIndex -> Commitment -> SignedCommitment

-- | Convert Secret to SharedSeed.
secretToSharedSeed :: Secret -> SharedSeed

-- | Safely insert <a>SignedCommitment</a> into <a>CommitmentsMap</a>.
insertSignedCommitment :: SignedCommitment -> CommitmentsMap -> CommitmentsMap

-- | Safely delete <a>SignedCommitment</a> from <a>CommitmentsMap</a>.
deleteSignedCommitment :: StakeholderId -> CommitmentsMap -> CommitmentsMap

-- | Compute difference of two <a>CommitmentsMap</a>s.
diffCommMap :: CommitmentsMap -> CommitmentsMap -> CommitmentsMap

-- | Compute intersection of two <a>CommitmentsMap</a>s.
intersectCommMap :: CommitmentsMap -> CommitmentsMap -> CommitmentsMap

-- | Generalized version of <a>intersectCommMap</a> which makes it possible
--   to intersect with different maps.
intersectCommMapWith :: (map -> HashMap StakeholderId x) -> CommitmentsMap -> map -> CommitmentsMap

-- | Check that the VSS certificate has valid TTL: i. e. it is in
--   '[vssMinTTL, vssMaxTTL]'.
checkCertTTL :: EpochIndex -> VssCertificate -> Bool

-- | Verify signature in SignedCommitment using epoch index.
--   
--   #checkSig
verifyCommitmentSignature :: Bi Commitment => EpochIndex -> SignedCommitment -> Bool

-- | Verify SignedCommitment using public key and epoch index.
--   
--   #verifyCommitmentSignature #verifyCommitment
verifySignedCommitment :: Bi Commitment => EpochIndex -> SignedCommitment -> VerificationRes

-- | Verify that Commitment is correct.
--   
--   #verifyEncShare
verifyCommitment :: Commitment -> Bool

-- | Verify that Secret provided with Opening corresponds to given
--   commitment.
--   
--   #verifySecretProof
verifyOpening :: Commitment -> Opening -> Bool
_gpCertificates :: GtPayload -> VssCertificatesMap

-- | Construct <a>GtProof</a> from <a>GtPayload</a>.
mkGtProof :: GtPayload -> GtProof

-- | Commitment is a message generated during the first stage of
--   GodTossing. It contains encrypted shares and proof of secret.
--   Invariant which must be ensured: commShares is not empty.
data Commitment
Commitment :: !(AsBinary SecretSharingExtra) -> !(AsBinary SecretProof) -> !(HashMap (AsBinary VssPublicKey) (NonEmpty (AsBinary EncShare))) -> Commitment
[commExtra] :: Commitment -> !(AsBinary SecretSharingExtra)
[commProof] :: Commitment -> !(AsBinary SecretProof)
[commShares] :: Commitment -> !(HashMap (AsBinary VssPublicKey) (NonEmpty (AsBinary EncShare)))

-- | Signature which ensures that commitment was generated by node with
--   given public key for given epoch.
type CommitmentSignature = Signature (EpochIndex, Commitment)
type SignedCommitment = (PublicKey, Commitment, CommitmentSignature)

-- | <a>CommitmentsMap</a> is a wrapper for 'HashMap StakeholderId
--   SignedCommitment' which ensures that keys are consistent with values,
--   i. e. <a>PublicKey</a> from <a>SignedCommitment</a> corresponds to key
--   which is <a>StakeholderId</a>.
data CommitmentsMap

-- | Safe constructor of <a>CommitmentsMap</a>.
mkCommitmentsMap :: [SignedCommitment] -> CommitmentsMap

-- | Unsafe straightforward constructor of <a>CommitmentsMap</a>.
mkCommitmentsMapUnsafe :: HashMap StakeholderId SignedCommitment -> CommitmentsMap

-- | Opening reveals secret.
newtype Opening
Opening :: (AsBinary Secret) -> Opening
[getOpening] :: Opening -> (AsBinary Secret)
type OpeningsMap = HashMap StakeholderId Opening

-- | Each node generates several <tt>SharedSeed</tt>s, breaks every
--   <tt>SharedSeed</tt> into <a>Share</a>s, and sends those encrypted
--   shares to other nodes (for i-th commitment at i-th element of NonEmpty
--   list) In a <a>SharesMap</a>, for each node we collect shares which
--   said node has received and decrypted.
--   
--   Specifically, if node identified by <tt>Address</tt> X has received
--   NonEmpty list of shares from node identified by key Y, this NonEmpty
--   list will be at <tt>sharesMap ! X ! Y</tt>.
type InnerSharesMap = HashMap StakeholderId (NonEmpty (AsBinary Share))
type SharesMap = HashMap StakeholderId InnerSharesMap
type SharesDistribution = HashMap StakeholderId Word16

-- | VssCertificate allows VssPublicKey to participate in MPC. Each
--   stakeholder should create a Vss keypair, sign VSS public key with
--   signing key and send it into blockchain.
--   
--   A public key of node is included in certificate in order to enable
--   validation of it using only node's P2PKH address. Expiry epoch is last
--   epoch when certificate is valid, expiry epoch is included in
--   certificate and signature.
--   
--   Other nodes accept this certificate if it is valid and if node has
--   enough stake.
--   
--   Invariant: 'checkSig vcSigningKey (vcVssKey, vcExpiryEpoch)
--   vcSignature'.
data VssCertificate

-- | Make VssCertificate valid up to given epoch using <a>SecretKey</a> to
--   sign data.
mkVssCertificate :: SecretKey -> AsBinary VssPublicKey -> EpochIndex -> VssCertificate

-- | Recreate <a>VssCertificate</a> from its contents. This function main
--   <a>fail</a> if data is invalid.
recreateVssCertificate :: MonadFail m => AsBinary VssPublicKey -> EpochIndex -> Signature (AsBinary VssPublicKey, EpochIndex) -> PublicKey -> m VssCertificate
getCertId :: VssCertificate -> StakeholderId

-- | VssCertificatesMap contains all valid certificates collected during
--   some period of time.
type VssCertificatesMap = HashMap StakeholderId VssCertificate

-- | Safe constructor of <a>VssCertificatesMap</a>. TODO: wrap into
--   newtype.
mkVssCertificatesMap :: [VssCertificate] -> VssCertificatesMap

-- | Payload included into blocks.
data GtPayload
CommitmentsPayload :: !CommitmentsMap -> !VssCertificatesMap -> GtPayload
OpeningsPayload :: !OpeningsMap -> !VssCertificatesMap -> GtPayload
SharesPayload :: !SharesMap -> !VssCertificatesMap -> GtPayload
CertificatesPayload :: !VssCertificatesMap -> GtPayload

-- | Proof of GtPayload.
data GtProof
CommitmentsProof :: !(Hash CommitmentsMap) -> !(Hash VssCertificatesMap) -> GtProof
OpeningsProof :: !(Hash OpeningsMap) -> !(Hash VssCertificatesMap) -> GtProof
SharesProof :: !(Hash SharesMap) -> !(Hash VssCertificatesMap) -> GtProof
CertificatesProof :: !(Hash VssCertificatesMap) -> GtProof
type NodeSet = HashSet StakeholderId

-- | Data type for error during seed calculation.
data SeedError

-- | Some nodes in the <tt>OpeningsMap</tt> aren't in the set of
--   participants
ExtraOpenings :: !(HashSet StakeholderId) -> SeedError

-- | Some nodes in the <tt>SharesMap</tt> aren't in the set of participants
ExtraShares :: !(HashSet StakeholderId) -> SeedError

-- | Some participants aren't richmen
NonRichmenParticipants :: !(HashSet StakeholderId) -> SeedError

-- | There was no majority of stake participating (first parameter –
--   participating stake, second – total richmen stake)
NotEnoughParticipatingStake :: !Coin -> !Coin -> SeedError

-- | There were no good secrets so a seed couldn't be generated
NoSecrets :: SeedError

-- | Commitment can't be deserialized or didn't match secret (either
--   recovered or in openings)
BrokenCommitment :: !StakeholderId -> SeedError

-- | Secret couldn't be recovered, or wasn't found in either
--   <tt>OpeningsMap</tt> or <tt>SharesMap</tt>
NoSecretFound :: !StakeholderId -> SeedError

-- | Secret can't be deserialized
BrokenSecret :: !StakeholderId -> SeedError

-- | Share can't be deserialized
BrokenShare :: !StakeholderId -> SeedError

-- | Some errors during computation of commitment distribution
CommitmentDistrError :: !Text -> SeedError
hasCommitment :: StakeholderId -> GtGlobalState -> Bool
hasOpening :: StakeholderId -> GtGlobalState -> Bool
hasShares :: StakeholderId -> GtGlobalState -> Bool
hasVssCertificate :: StakeholderId -> GtGlobalState -> Bool
sanityChecksGtPayload :: MonadError TossVerFailure m => Either EpochIndex (MainBlockHeader ssc) -> GtPayload -> m ()

-- | Figure out the threshold (i.e. how many secret shares would be
--   required to recover each node's secret) using number of participants.
vssThreshold :: Integral a => a -> Threshold
getStableCertsPure :: EpochIndex -> VssCertData -> VssCertificatesMap

-- | Certificates in genesis represented as <a>VssCertificatesMap</a>.
genesisCertificates :: VssCertificatesMap

-- | List of <a>VssKeyPair</a>s in genesis.
genesisDevVssKeyPairs :: [VssKeyPair]

-- | Check whether SSC data with given tag and public key can be added to
--   current local data.
sscIsDataUseful :: (WithLogger m, MonadDB m, WithNodeContext kek m, MonadSlots m, MonadSscMem SscGodTossing m) => GtTag -> StakeholderId -> m Bool

-- | Process <a>SignedCommitment</a> received from network, checking it
--   against current state (global + local) and adding to local state if
--   it's valid.
sscProcessCommitment :: forall m. GtDataProcessingMode m => SignedCommitment -> m ()

-- | Process <a>Opening</a> received from network, checking it against
--   current state (global + local) and adding to local state if it's
--   valid.
sscProcessOpening :: GtDataProcessingMode m => StakeholderId -> Opening -> m ()

-- | Process <a>InnerSharesMap</a> received from network, checking it
--   against current state (global + local) and adding to local state if
--   it's valid.
sscProcessShares :: GtDataProcessingMode m => StakeholderId -> InnerSharesMap -> m ()

-- | Process <a>VssCertificate</a> received from network, checking it
--   against current state (global + local) and adding to local state if
--   it's valid.
sscProcessCertificate :: GtDataProcessingMode m => VssCertificate -> m ()

-- | Clean-up some data when new slot starts. This function is only needed
--   for garbage collection, it doesn't affect validity of local data.
--   Currently it does nothing, but maybe later we'll decide to do
--   clean-up.
localOnNewSlot :: MonadSscMem SscGodTossing m => SlotId -> m ()
data GtLocalData
GtLocalData :: !TossModifier -> !EpochIndex -> GtLocalData

-- | <a>TossModifier</a> which also serves as mempool of GT data, because
--   for GodTossing modifier and mempool are same.
[_ldModifier] :: GtLocalData -> !TossModifier

-- | Epoch for which this mempool can be used to form payload.
[_ldEpoch] :: GtLocalData -> !EpochIndex
ldModifier :: Lens' GtLocalData TossModifier
ldEpoch :: Lens' GtLocalData EpochIndex

-- | Get our commitment for given epoch if it's known.
getOurCommitment :: MonadDB m => EpochIndex -> m (Maybe SignedCommitment)

-- | Get our opening corresponding for given epoch if it's known.
getOurOpening :: MonadDB m => EpochIndex -> m (Maybe Opening)

-- | Put our secret for given epoch.
putOurSecret :: MonadDB m => SignedCommitment -> Opening -> EpochIndex -> m ()

-- | Calculate SharedSeed. SharedSeed is a random bytestring that all nodes
--   generate together and agree on.
--   
--   TODO: do we need to check secrets' lengths? Probably not.
calculateSeed :: CommitmentsMap -> OpeningsMap -> SharesMap -> RichmenStake -> Either SeedError SharedSeed
getGlobalCerts :: (MonadSscMem SscGodTossing m, MonadIO m) => SlotId -> m VssCertificatesMap
gtGetGlobalState :: (MonadSscMem SscGodTossing m, MonadIO m) => m GtGlobalState

-- | Get stable VSS certificates for given epoch.
getStableCerts :: (MonadSscMem SscGodTossing m, MonadIO m) => EpochIndex -> m VssCertificatesMap

-- | Retrieve <a>SignedCommitment</a> of given stakeholder if it's known.
getCommitment :: MonadTossRead m => StakeholderId -> m (Maybe SignedCommitment)

-- | Check whether there is a <a>SignedCommitment</a> from given
--   stakeholder.
hasCommitmentToss :: MonadTossRead m => StakeholderId -> m Bool

-- | Check whether there is an <a>Opening</a> from given stakeholder.
hasOpeningToss :: MonadTossRead m => StakeholderId -> m Bool

-- | Check whether there is <a>InnerSharesMap</a> from given stakeholder.
hasSharesToss :: MonadTossRead m => StakeholderId -> m Bool

-- | Check whether there is <tt>VssCertificate</tt> from given stakeholder.
hasCertificateToss :: MonadTossRead m => StakeholderId -> m Bool

-- | Get <a>VssCertificatesMap</a> containing <a>StakeholderId</a>s and
--   <tt>VssPublicKey</tt>s of participating nodes for given epoch.
getParticipants :: (MonadError TossVerFailure m, MonadToss m) => EpochIndex -> m VssCertificatesMap

-- | Compute <tt>VssCertificate</tt>s of GodTossing participants using set
--   of richmen and stable certificates.
computeParticipants :: RichmenSet -> VssCertificatesMap -> VssCertificatesMap
computeSharesDistr :: MonadError TossVerFailure m => RichmenStake -> m SharesDistribution
checkCommitmentsPayload :: (MonadToss m, MonadError TossVerFailure m) => EpochIndex -> CommitmentsMap -> m ()
checkOpeningsPayload :: (MonadToss m, MonadError TossVerFailure m) => OpeningsMap -> m ()
checkSharesPayload :: (MonadToss m, MonadError TossVerFailure m) => EpochIndex -> SharesMap -> m ()
checkCertificatesPayload :: (MonadToss m, MonadError TossVerFailure m) => EpochIndex -> VssCertificatesMap -> m ()
checkPayload :: (MonadToss m, MonadError TossVerFailure m) => EpochIndex -> GtPayload -> m ()
verifyEntriesGuardM :: MonadError TossVerFailure m => (entry -> key) -> (entry -> verificationVal) -> (NonEmpty key -> TossVerFailure) -> (verificationVal -> m Bool) -> [entry] -> m ()

-- | Type class which provides functions necessary for read-only
--   verification of GodTossing data.
class (Monad m, WithLogger m) => MonadTossRead m where getCommitments = lift getCommitments getOpenings = lift getOpenings getShares = lift getShares getVssCertData = lift getVssCertData getVssCertificates = lift getVssCertificates getStableCertificates = lift . getStableCertificates getRichmen = lift . getRichmen

-- | Get <a>CommitmentsMap</a> with all commitments.
getCommitments :: MonadTossRead m => m CommitmentsMap

-- | Get <a>OpeningsMap</a> with all openings.
getOpenings :: MonadTossRead m => m OpeningsMap

-- | Get <a>SharesMap</a> with all shares.
getShares :: MonadTossRead m => m SharesMap

-- | Get <a>VssCertificatesMap</a> with all VSS certificates.
getVssCertificates :: MonadTossRead m => m VssCertificatesMap

-- | Get <a>VssCertData</a>.
getVssCertData :: MonadTossRead m => m VssCertData

-- | Retrieve all stable <a>VssCertificate</a>s for given epoch.
getStableCertificates :: MonadTossRead m => EpochIndex -> m VssCertificatesMap

-- | Retrieve richmen for given epoch if they are known.
getRichmen :: MonadTossRead m => EpochIndex -> m (Maybe RichmenStake)

-- | Get <a>CommitmentsMap</a> with all commitments.
getCommitments :: (MonadTossRead m, MonadTrans t, MonadTossRead m', t m' ~ m) => m CommitmentsMap

-- | Get <a>OpeningsMap</a> with all openings.
getOpenings :: (MonadTossRead m, MonadTrans t, MonadTossRead m', t m' ~ m) => m OpeningsMap

-- | Get <a>SharesMap</a> with all shares.
getShares :: (MonadTossRead m, MonadTrans t, MonadTossRead m', t m' ~ m) => m SharesMap

-- | Get <a>VssCertData</a>.
getVssCertData :: (MonadTossRead m, MonadTrans t, MonadTossRead m', t m' ~ m) => m VssCertData

-- | Get <a>VssCertificatesMap</a> with all VSS certificates.
getVssCertificates :: (MonadTossRead m, MonadTrans t, MonadTossRead m', t m' ~ m) => m VssCertificatesMap

-- | Retrieve all stable <a>VssCertificate</a>s for given epoch.
getStableCertificates :: (MonadTossRead m, MonadTrans t, MonadTossRead m', t m' ~ m) => EpochIndex -> m VssCertificatesMap

-- | Retrieve richmen for given epoch if they are known.
getRichmen :: (MonadTossRead m, MonadTrans t, MonadTossRead m', t m' ~ m) => EpochIndex -> m (Maybe RichmenStake)

-- | Type class which provides function necessary for verification of
--   GodTossing data with ability to modify state.
class MonadTossRead m => MonadToss m where putCommitment = lift . putCommitment putOpening id = lift . putOpening id putShares id = lift . putShares id putCertificate = lift . putCertificate resetCO = lift resetCO resetShares = lift resetShares delCommitment = lift . delCommitment delOpening = lift . delOpening delShares = lift . delShares setEpochOrSlot = lift . setEpochOrSlot

-- | Put <a>SignedCommitment</a> into state.
putCommitment :: MonadToss m => SignedCommitment -> m ()

-- | Put <a>Opening</a> from given stakeholder into state.
putOpening :: MonadToss m => StakeholderId -> Opening -> m ()

-- | Put <tt>InnerShares</tt> from given stakeholder into state.
putShares :: MonadToss m => StakeholderId -> InnerSharesMap -> m ()

-- | Put <a>VssCertificate</a> into state.
putCertificate :: MonadToss m => VssCertificate -> m ()

-- | Reset Commitments and Openings.
resetCO :: MonadToss m => m ()

-- | Reset Shares.
resetShares :: MonadToss m => m ()

-- | Delete commitment of given stakeholder.
delCommitment :: MonadToss m => StakeholderId -> m ()

-- | Delete opening of given stakeholder.
delOpening :: MonadToss m => StakeholderId -> m ()

-- | Delete shares of given stakeholder.
delShares :: MonadToss m => StakeholderId -> m ()

-- | This function is called when block with given <a>EpochOrSlot</a> is
--   applied.
setEpochOrSlot :: MonadToss m => EpochOrSlot -> m ()

-- | Put <a>SignedCommitment</a> into state.
putCommitment :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => SignedCommitment -> m ()

-- | Put <a>Opening</a> from given stakeholder into state.
putOpening :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => StakeholderId -> Opening -> m ()

-- | Put <tt>InnerShares</tt> from given stakeholder into state.
putShares :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => StakeholderId -> InnerSharesMap -> m ()

-- | Put <a>VssCertificate</a> into state.
putCertificate :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => VssCertificate -> m ()

-- | Reset Commitments and Openings.
resetCO :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => m ()

-- | Reset Shares.
resetShares :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => m ()

-- | Delete commitment of given stakeholder.
delCommitment :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => StakeholderId -> m ()

-- | Delete opening of given stakeholder.
delOpening :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => StakeholderId -> m ()

-- | Delete shares of given stakeholder.
delShares :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => StakeholderId -> m ()

-- | This function is called when block with given <a>EpochOrSlot</a> is
--   applied.
setEpochOrSlot :: (MonadToss m, MonadTrans t, MonadToss m', t m' ~ m) => EpochOrSlot -> m ()
data TossVerFailure
NotCommitmentPhase :: !SlotId -> TossVerFailure
NotOpeningPhase :: !SlotId -> TossVerFailure
NotSharesPhase :: !SlotId -> TossVerFailure
NotIntermediatePhase :: !SlotId -> TossVerFailure
CurrentSlotUnknown :: TossVerFailure
DifferentEpoches :: !EpochIndex -> !EpochIndex -> TossVerFailure
TossUnknownRichmen :: !EpochIndex -> TossVerFailure
NoRichmen :: !EpochIndex -> TossVerFailure
CommitmentInvalid :: !NEStIds -> TossVerFailure
CommitingNoParticipants :: !NEStIds -> TossVerFailure
CommitmentAlreadySent :: !NEStIds -> TossVerFailure
CommSharesOnWrongParticipants :: !NEStIds -> TossVerFailure
OpeningAlreadySent :: !NEStIds -> TossVerFailure
OpeningWithoutCommitment :: !NEStIds -> TossVerFailure
OpeningNotMatchCommitment :: !NEStIds -> TossVerFailure
SharesNotRichmen :: !NEStIds -> TossVerFailure
InternalShareWithoutCommitment :: !NEStIds -> TossVerFailure
SharesAlreadySent :: !NEStIds -> TossVerFailure
DecrSharesNotMatchCommitment :: !NEStIds -> TossVerFailure
CertificateAlreadySent :: !NEStIds -> TossVerFailure
CertificateNotRichmen :: !NEStIds -> TossVerFailure
CertificateInvalidSign :: !(NonEmpty (StakeholderId, VssCertificate)) -> TossVerFailure
CertificateInvalidTTL :: !(NonEmpty VssCertificate) -> TossVerFailure
TossInternallError :: !Text -> TossVerFailure

-- | Verify <a>GtPayload</a> with respect to data provided by MonadToss. If
--   data is valid it is also applied. Otherwise TossVerFailure is thrown
--   using <a>MonadError</a> type class.
verifyAndApplyGtPayload :: (MonadToss m, MonadError TossVerFailure m) => Either EpochIndex (MainBlockHeader ssc) -> GtPayload -> m ()

-- | Apply genesis block for given epoch to <tt>Toss</tt> state.
applyGenesisBlock :: MonadToss m => EpochIndex -> m ()

-- | Rollback application of <a>GtPayload</a>s in <tt>Toss</tt>. First
--   argument is <a>EpochOrSlot</a> of oldest block which is subject to
--   rollback.
rollbackGT :: MonadToss m => EpochOrSlot -> NewestFirst [] GtPayload -> m ()

-- | Apply as much data from given <a>TossModifier</a> as possible.
normalizeToss :: forall m. MonadToss m => EpochIndex -> TossModifier -> m ()
newtype PureToss a
PureToss :: NamedPureLogger (RWS MultiRichmenStake () GtGlobalState) a -> PureToss a
[getPureToss] :: PureToss a -> NamedPureLogger (RWS MultiRichmenStake () GtGlobalState) a
type MultiRichmenStake = HashMap EpochIndex RichmenStake
type MultiRichmenSet = HashMap EpochIndex RichmenSet
runPureToss :: MultiRichmenStake -> GtGlobalState -> PureToss a -> (a, GtGlobalState, [LogEvent])
runPureTossWithLogger :: WithLogger m => MultiRichmenStake -> GtGlobalState -> PureToss a -> m (a, GtGlobalState)
evalPureTossWithLogger :: WithLogger m => MultiRichmenStake -> GtGlobalState -> PureToss a -> m a
execPureTossWithLogger :: WithLogger m => MultiRichmenStake -> GtGlobalState -> PureToss a -> m GtGlobalState

-- | Monad transformer which stores TossModifier and implements writable
--   MonadToss.
--   
--   <ul>
--   <li><i>WARNING</i> This transformer uses StateT and is intended for
--   single-threaded usage only.</li>
--   </ul>
type TossT = StateT TossModifier
runTossT :: TossModifier -> TossT m a -> m (a, TossModifier)
evalTossT :: Monad m => TossModifier -> TossT m a -> m a
execTossT :: Monad m => TossModifier -> TossT m a -> m TossModifier

-- | Tag corresponding to GodTossing data.
data GtTag
CommitmentMsg :: GtTag
OpeningMsg :: GtTag
SharesMsg :: GtTag
VssCertificateMsg :: GtTag
isGoodSlotForTag :: GtTag -> LocalSlotIndex -> Bool
isGoodSlotIdForTag :: GtTag -> SlotId -> Bool
data TossModifier
TossModifier :: !CommitmentsMap -> !OpeningsMap -> !SharesMap -> !VssCertificatesMap -> TossModifier
[_tmCommitments] :: TossModifier -> !CommitmentsMap
[_tmOpenings] :: TossModifier -> !OpeningsMap
[_tmShares] :: TossModifier -> !SharesMap
[_tmCertificates] :: TossModifier -> !VssCertificatesMap
tmCommitments :: Lens' TossModifier CommitmentsMap
tmOpenings :: Lens' TossModifier OpeningsMap
tmShares :: Lens' TossModifier SharesMap
tmCertificates :: Lens' TossModifier VssCertificatesMap

-- | Data type which represents shared seed calculation tag in
--   -XTypeApplication hacks with type families.
data SscGodTossing

-- | Tag corresponding to GodTossing data.
data GtTag
CommitmentMsg :: GtTag
OpeningMsg :: GtTag
SharesMsg :: GtTag
VssCertificateMsg :: GtTag

-- | Data message. Can be used to send actual data.
data GtMsgContents
MCCommitment :: !SignedCommitment -> GtMsgContents
MCOpening :: !StakeholderId -> !Opening -> GtMsgContents
MCShares :: !StakeholderId -> !InnerSharesMap -> GtMsgContents
MCVssCertificate :: !VssCertificate -> GtMsgContents

-- | GtTag appropriate for given DataMsg.
msgContentsTag :: GtMsgContents -> GtTag
_MCCommitment :: Prism' GtMsgContents SignedCommitment
_MCOpening :: Prism' GtMsgContents (StakeholderId, Opening)
_MCShares :: Prism' GtMsgContents (StakeholderId, InnerSharesMap)
_MCVssCertificate :: Prism' GtMsgContents VssCertificate

-- | Global state of GodTossing, contains relevant SSC data from blocks.
data GtGlobalState
GtGlobalState :: !CommitmentsMap -> !OpeningsMap -> !SharesMap -> !VssCertData -> GtGlobalState

-- | Commitments are added during the first phase of epoch.
[_gsCommitments] :: GtGlobalState -> !CommitmentsMap

-- | Openings are added during the second phase of epoch.
[_gsOpenings] :: GtGlobalState -> !OpeningsMap

-- | Decrypted shares to be used in the third phase.
[_gsShares] :: GtGlobalState -> !SharesMap

-- | Vss certificates are added at any time if they are valid and received
--   from stakeholders.
[_gsVssCertificates] :: GtGlobalState -> !VssCertData
data GtContext
GtContext :: !VssKeyPair -> !(TVar Bool) -> GtContext

-- | Vss key pair used for MPC.
[gtcVssKeyPair] :: GtContext -> !VssKeyPair

-- | Flag which determines whether we want to participate in SSC.
[gtcParticipateSsc] :: GtContext -> !(TVar Bool)
data GtParams
GtParams :: !Bool -> !VssKeyPair -> GtParams

-- | Whether node should participate in SSC in case SSC requires
--   participation.
[gtpSscEnabled] :: GtParams -> !Bool

-- | Key pair used for secret sharing
[gtpVssKeyPair] :: GtParams -> !VssKeyPair
data GtSecretStorage
GtSecretStorage :: !SignedCommitment -> !Opening -> !EpochIndex -> GtSecretStorage

-- | Our commitment.
[gssCommitment] :: GtSecretStorage -> !SignedCommitment

-- | Corresponding opening
[gssOpening] :: GtSecretStorage -> !Opening

-- | Epoch for which this secret were generated
[gssEpoch] :: GtSecretStorage -> !EpochIndex
gsCommitments :: Lens' GtGlobalState CommitmentsMap
gsOpenings :: Lens' GtGlobalState OpeningsMap
gsShares :: Lens' GtGlobalState SharesMap
gsVssCertificates :: Lens' GtGlobalState VssCertData
createGtContext :: MonadIO m => GtParams -> m GtContext

-- | Wrapper around <a>VssCertificate</a> with TTL. Every
--   <a>VssCertificate</a> has own TTL. Wrapper supports simple
--   <a>HashMap</a> operations. Wrapper holds <a>VssCertificatesMap</a> and
--   <a>Set</a> of certificates sorted by expiry epoch.
data VssCertData
VssCertData :: !EpochOrSlot -> !VssCertificatesMap -> !(HashMap StakeholderId EpochOrSlot) -> !(Set (EpochOrSlot, StakeholderId)) -> !(Set (EpochOrSlot, StakeholderId)) -> !(Set (EpochOrSlot, (StakeholderId, EpochOrSlot, VssCertificate))) -> VssCertData

-- | Last known slot, every element of expirySlotSet &gt; lastKnownEoS
[lastKnownEoS] :: VssCertData -> !EpochOrSlot

-- | Not expired certificates
[certs] :: VssCertData -> !VssCertificatesMap

-- | Slot when certs was inserted. It is needed for deletion from
--   <tt>insSlotSet</tt> (by <a>StakeholderId</a>).
[whenInsMap] :: VssCertData -> !(HashMap StakeholderId EpochOrSlot)

-- | Set of pairs (insertion slot, address hash) Every element of
--   insSlotSet &lt;= lastKnownEoS
[whenInsSet] :: VssCertData -> !(Set (EpochOrSlot, StakeholderId))

-- | Set of pairs (expiry slot, address hash). Expiry slot is first slot
--   when certificate expires. Pairs are sorted by expiry slot (in
--   increasing order, so the oldest certificate is first element).
[whenExpire] :: VssCertData -> !(Set (EpochOrSlot, StakeholderId))

-- | Set of expired certs for current <a>lastKnownEoS</a>. We store only
--   certificates which expried no earlier than in previous epoch. Set
--   (full expired slot, (id, insertion slot, cert))
[expiredCerts] :: VssCertData -> !(Set (EpochOrSlot, (StakeholderId, EpochOrSlot, VssCertificate)))

-- | Create empty <a>VssCertData</a>.
empty :: VssCertData

-- | Remove old certificate corresponding to the specified
--   <a>StakeholderId</a> and insert new certificate.
insert :: VssCertificate -> VssCertData -> VssCertData

-- | Lookup certificate corresponding to the specified
--   <a>StakeholderId</a>.
lookup :: StakeholderId -> VssCertData -> Maybe VssCertificate

-- | Lookup expiry epoch of certificate corresponding to the specified
--   <a>StakeholderId</a>.
lookupExpiryEpoch :: StakeholderId -> VssCertData -> Maybe EpochIndex
setLastKnownSlot :: SlotId -> VssCertData -> VssCertData

-- | Set last known slot (lks). 1. If new lks is bigger than
--   <a>lastKnownEoS</a> then some expired certificates will be removed. 2.
--   If new lks is less than <a>lastKnownEoS</a> then some inserted after
--   <tt>nlks</tt> certificates will be removed (and <a>whenExpire</a>)
--   also will be updated.
setLastKnownEoS :: EpochOrSlot -> VssCertData -> VssCertData

-- | Ids of stakeholders issued certificates.
keys :: VssCertData -> [StakeholderId]

-- | Return True if the specified address hash is present in the map, False
--   otherwise.
member :: StakeholderId -> VssCertData -> Bool

-- | Convert expiry epoch of certificate to <tt>FlatSlotId</tt>.
expiryEpoch :: VssCertificate -> EpochIndex
expiryEoS :: VssCertificate -> EpochOrSlot
fromList :: [VssCertificate] -> VssCertData

-- | Delete certificate corresponding to the specified
--   <a>StakeholderId</a>. This function is dangerous, because after using
--   it you can't rollback deleted certificates. Use carefully.
delete :: StakeholderId -> VssCertData -> VssCertData

-- | This function is dangerous, because after you using it you can't
--   rollback deleted certificates. Use carefully.
difference :: VssCertData -> HashMap StakeholderId a -> VssCertData

-- | Filtering the certificates. This function is dangerous, because after
--   you using it you can't rollback deleted certificates. Use carefully.
filter :: (StakeholderId -> Bool) -> VssCertData -> VssCertData


-- | Txp system reexports.
module Pos.Txp
data TxpError

-- | Something bad happened inside Txp
TxpInternalError :: !Text -> TxpError

-- | Settings used for global transactions data processing used by a simple
--   full node.
txpGlobalSettings :: TxpGlobalSettings
data ApplyBlocksSettings extra m
ApplyBlocksSettings :: (TxpBlund -> m ()) -> (extra -> SomeBatchOp) -> ApplyBlocksSettings extra m
[absApplySingle] :: ApplyBlocksSettings extra m -> TxpBlund -> m ()
[absExtraOperations] :: ApplyBlocksSettings extra m -> extra -> SomeBatchOp
applyBlocksWith :: (TxpGlobalApplyMode m, Default extra) => ApplyBlocksSettings extra (ToilT extra (DBTxp m)) -> OldestFirst NE TxpBlund -> m SomeBatchOp
blundToAuxNUndo :: TxpBlund -> [(TxAux, TxUndo)]

-- | Convert <a>GenericToilModifier</a> to batch of database operations.
genericToilModifierToBatch :: (e -> SomeBatchOp) -> GenericToilModifier e -> SomeBatchOp

-- | Run action which requires toil interfaces.
runToilAction :: (MonadDB m, Default e) => ToilT e (DBTxp m) a -> m (a, GenericToilModifier e)
txProcessTransaction :: TxpLocalWorkMode m => (TxId, TxAux) -> m ()

-- | <ol>
--   <li>Recompute UtxoView by current MemPool | 2. Remove invalid
--   transactions from MemPool | 3. Set new tip to txp local data</li>
--   </ol>
txNormalize :: (MonadDB m, MonadTxpMem () m) => m ()

-- | Reduced equivalent of <tt>MonadReader (GenericTxpLocalData mw) m</tt>.
type MonadTxpMem ext = MonadReader TxpHolderTag (GenericTxpLocalData ext)
askTxpMem :: MonadTxpMem ext m => m (GenericTxpLocalData ext)
data TxpHolderTag
getUtxoModifier :: (MonadTxpMem e m, MonadIO m) => m UtxoModifier
getLocalTxsNUndo :: (MonadIO m, MonadTxpMem e m) => m ([(TxId, TxAux)], HashMap TxId (NonEmpty TxOutAux))
getMemPool :: (MonadIO m, MonadTxpMem e m) => m MemPool
getLocalTxs :: (MonadIO m, MonadTxpMem e m) => m [(TxId, TxAux)]
getLocalTxsMap :: (MonadIO m, MonadTxpMem e m) => m (HashMap TxId TxAux)
getTxpExtra :: (MonadIO m, MonadTxpMem e m) => m e
modifyTxpLocalData :: (MonadIO m, MonadTxpMem ext m) => (GenericTxpLocalDataPure ext -> (a, GenericTxpLocalDataPure ext)) -> m a
setTxpLocalData :: (MonadIO m, MonadTxpMem ext m) => GenericTxpLocalDataPure ext -> m ()
clearTxpMemPool :: (MonadIO m, MonadTxpMem ext m, Default ext) => m ()
type TxpHolder ext = ReaderT TxpHolderTag (GenericTxpLocalData ext)
mkTxpLocalData :: (Default e, MonadIO m) => UtxoModifier -> HeaderHash -> m (GenericTxpLocalData e)
runTxpHolder :: GenericTxpLocalData ext -> TxpHolder ext m a -> m a

-- | LocalData of transactions processing. There are two invariants which
--   must hold for local data (where um is UtxoModifier, memPool is MemPool
--   and tip is HeaderHash): 1. Suppose <tt>blks</tt> is sequence of blocks
--   from the very beginning up to <tt>tip</tt>. If one applies
--   <tt>blks</tt> to genesis Utxo, resulting Utxo (let's call it
--   <tt>utxo1</tt>) will be such that all transactions from
--   <tt>memPool</tt> are valid with respect to it. 2. If one applies all
--   transactions from <tt>memPool</tt> to <tt>utxo1</tt>, resulting Utxo
--   will be equivalent to <tt>um</tt> with respect to MonadUtxo.
--   
--   Memory state of Txp. Generic version.
data GenericTxpLocalData extra
TxpLocalData :: !(TVar UtxoModifier) -> !(TVar MemPool) -> !(TVar UndoMap) -> !(TVar HeaderHash) -> !(TVar extra) -> GenericTxpLocalData extra
[txpUtxoModifier] :: GenericTxpLocalData extra -> !(TVar UtxoModifier)
[txpMemPool] :: GenericTxpLocalData extra -> !(TVar MemPool)
[txpUndos] :: GenericTxpLocalData extra -> !(TVar UndoMap)
[txpTip] :: GenericTxpLocalData extra -> !(TVar HeaderHash)
[txpExtra] :: GenericTxpLocalData extra -> !(TVar extra)

-- | Pure version of GenericTxpLocalData.
type GenericTxpLocalDataPure extra = (UtxoModifier, MemPool, UndoMap, HeaderHash, extra)

-- | Memory state of Txp. This version is used by actual Txp
--   implementation.
type TxpLocalData = GenericTxpLocalData ()

-- | Pure version of TxpLocalData.
type TxpLocalDataPure = GenericTxpLocalDataPure ()
txListeners :: WorkMode ssc m => m ([ListenerSpec m], OutSpecs)
txStubListeners :: WithLogger m => ([ListenerSpec m], OutSpecs)
data TxMsgTag
TxMsgTag :: TxMsgTag

-- | Data message. Can be used to send one transaction per message.
data TxMsgContents
TxMsgContents :: !Tx -> !TxWitness -> !TxDistribution -> TxMsgContents
[dmTx] :: TxMsgContents -> !Tx
[dmWitness] :: TxMsgContents -> !TxWitness
[dmDistribution] :: TxMsgContents -> !TxDistribution
class Monad m => MonadUtxoRead m where utxoGet = lift . utxoGet
utxoGet :: MonadUtxoRead m => TxIn -> m (Maybe TxOutAux)
utxoGet :: (MonadUtxoRead m, MonadTrans t, MonadUtxoRead m', t m' ~ m) => TxIn -> m (Maybe TxOutAux)
class MonadUtxoRead m => MonadUtxo m where utxoPut a = lift . utxoPut a utxoDel = lift . utxoDel
utxoPut :: MonadUtxo m => TxIn -> TxOutAux -> m ()
utxoPut :: (MonadUtxo m, MonadTrans t, MonadUtxo m', t m' ~ m) => TxIn -> TxOutAux -> m ()
utxoDel :: MonadUtxo m => TxIn -> m ()
utxoDel :: (MonadUtxo m, MonadTrans t, MonadUtxo m', t m' ~ m) => TxIn -> m ()
class Monad m => MonadBalancesRead m where getStake = lift . getStake getTotalStake = lift getTotalStake
getStake :: MonadBalancesRead m => StakeholderId -> m (Maybe Coin)
getTotalStake :: MonadBalancesRead m => m Coin
getStake :: (MonadBalancesRead m, MonadTrans t, MonadBalancesRead m', t m' ~ m) => StakeholderId -> m (Maybe Coin)
getTotalStake :: (MonadBalancesRead m, MonadTrans t, MonadBalancesRead m', t m' ~ m) => m Coin
class MonadBalancesRead m => MonadBalances m where setStake id = lift . setStake id setTotalStake = lift . setTotalStake
setStake :: MonadBalances m => StakeholderId -> Coin -> m ()
setTotalStake :: MonadBalances m => Coin -> m ()
setStake :: (MonadBalances m, MonadTrans t, MonadBalances m', t m' ~ m) => StakeholderId -> Coin -> m ()
setTotalStake :: (MonadBalances m, MonadTrans t, MonadBalances m', t m' ~ m) => Coin -> m ()

-- | Type class which lets get some environmental data needed for
--   transactions processing.
class Monad m => MonadToilEnv m where getToilEnv = lift getToilEnv
getToilEnv :: MonadToilEnv m => m ToilEnv
getToilEnv :: (MonadToilEnv m, MonadTrans t, MonadToilEnv m', t m' ~ m) => m ToilEnv
class Monad m => MonadTxPool m where hasTx = lift . hasTx poolSize = lift poolSize putTxWithUndo id tx = lift . putTxWithUndo id tx
hasTx :: MonadTxPool m => TxId -> m Bool
poolSize :: MonadTxPool m => m Int
putTxWithUndo :: MonadTxPool m => TxId -> TxAux -> TxUndo -> m ()
hasTx :: (MonadTxPool m, MonadTrans t, MonadTxPool m', t m' ~ m) => TxId -> m Bool
poolSize :: (MonadTxPool m, MonadTrans t, MonadTxPool m', t m' ~ m) => m Int
putTxWithUndo :: (MonadTxPool m, MonadTrans t, MonadTxPool m', t m' ~ m) => TxId -> TxAux -> TxUndo -> m ()
type DBTxp = TaggedTrans DBTxpTag IdentityT
runDBTxp :: DBTxp m a -> m a

-- | Result of transaction processing
data ToilVerFailure

-- | Transaction is already in the storage (cache)
ToilKnown :: ToilVerFailure
ToilTipsMismatch :: !HeaderHash -> !HeaderHash -> ToilVerFailure
[ttmOldTip] :: ToilVerFailure -> !HeaderHash
[ttmNewTip] :: ToilVerFailure -> !HeaderHash

-- | Local transaction storage is full -- can't accept more txs
ToilOverwhelmed :: ToilVerFailure

-- | Tx input is not a known unspent input.
ToilNotUnspent :: !TxIn -> ToilVerFailure
ToilOutGTIn :: !Integer -> !Integer -> ToilVerFailure
[tInputSum] :: ToilVerFailure -> !Integer
[tOutputSum] :: ToilVerFailure -> !Integer
ToilInconsistentTxAux :: !Text -> ToilVerFailure
ToilInvalidOutputs :: !Text -> ToilVerFailure
ToilInvalidInputs :: ![Text] -> ToilVerFailure
ToilTooLargeTx :: !Byte -> !Byte -> ToilVerFailure
[ttltSize] :: ToilVerFailure -> !Byte
[ttltLimit] :: ToilVerFailure -> !Byte
ToilUnknownAttributes :: !ByteString -> ToilVerFailure
type GlobalToilMode m = (MonadUtxo m, MonadBalances m, MonadToilEnv m, WithLogger m)

-- | Verify transactions correctness with respect to Utxo applying them
--   one-by-one. Note: transactions must be topsorted to pass check.
--   Warning: this function may apply some transactions and fail
--   eventually. Use it only on temporary data.
--   
--   If the first argument is <a>True</a>, all data (script versions,
--   witnesses, addresses, attributes) must be known. Otherwise unknown
--   data is just ignored.
verifyToil :: (GlobalToilMode m, MonadError ToilVerFailure m) => Bool -> [TxAux] -> m TxpUndo

-- | Apply transactions from one block. They must be valid (for example, it
--   implies topological sort).
applyToil :: GlobalToilMode m => [(TxAux, TxUndo)] -> m ()

-- | Rollback transactions from one block.
rollbackToil :: GlobalToilMode m => [(TxAux, TxUndo)] -> m ()
type LocalToilMode m = (MonadUtxo m, MonadToilEnv m, MonadTxPool m)

-- | Get rid of invalid transactions. All valid transactions will be added
--   to mem pool and applied to utxo.
normalizeToil :: (LocalToilMode m) => [(TxId, TxAux)] -> m ()

-- | Verify one transaction and also add it to mem pool and apply to utxo
--   if transaction is valid.
processTx :: (LocalToilMode m, MonadError ToilVerFailure m) => (TxId, TxAux) -> m TxUndo
verifyAndApplyTx :: (MonadUtxo m, MonadToilEnv m, MonadError ToilVerFailure m) => Bool -> (TxId, TxAux) -> m TxUndo

-- | Monad transformer which stores ToilModifier and implements writable
--   Toil type classes.
--   
--   <ul>
--   <li><i>WARNING</i> This transformer uses StateT and is intended for
--   single-threaded usage only. Used for block application now.</li>
--   </ul>
type ToilT ext m = StateT (GenericToilModifier ext) m

-- | Run ToilT using empty modifier. Should be used for global transaction
--   processing.
runToilTGlobal :: (Default ext, Functor m) => ToilT ext m a -> m (a, GenericToilModifier ext)

-- | Run ToilT using empty balances modifier. Should be used for local
--   transaction processing.
runToilTLocal :: (Functor m) => UtxoModifier -> MemPool -> UndoMap -> ToilT () m a -> m (a, ToilModifier)

-- | Execute ToilT using empty balances modifier. Should be used for local
--   transaction processing.
execToilTLocal :: (Functor m) => UtxoModifier -> MemPool -> UndoMap -> ToilT () m a -> m (ToilModifier)

-- | Like <a>runToilTLocal</a>, but takes extra data as argument.
runToilTLocalExtra :: (Functor m) => UtxoModifier -> MemPool -> UndoMap -> extra -> ToilT extra m a -> m (a, GenericToilModifier extra)

-- | Unspent transaction outputs.
--   
--   Transaction inputs are identified by (transaction ID, index in list of
--   output) pairs.
type Utxo = Map TxIn TxOutAux

-- | Format <a>Utxo</a> map for showing
formatUtxo :: Utxo -> Builder

-- | Specialized formatter for <a>Utxo</a>.
utxoF :: Format r (Utxo -> r)
data MemPool
MemPool :: !TxMap -> !Int -> MemPool
[_mpLocalTxs] :: MemPool -> !TxMap

-- | <tt>length</tt> is <tt>O(n)</tt> for <a>HashMap</a> so we store it
--   explicitly.
[_mpLocalTxsSize] :: MemPool -> !Int
mpLocalTxs :: Lens' MemPool TxMap
mpLocalTxsSize :: Lens' MemPool Int
type TxMap = HashMap TxId TxAux
data BalancesView
BalancesView :: !(HashMap StakeholderId Coin) -> !(Maybe Coin) -> BalancesView
[_bvStakes] :: BalancesView -> !(HashMap StakeholderId Coin)
[_bvTotal] :: BalancesView -> !(Maybe Coin)
bvStakes :: Lens' BalancesView (HashMap StakeholderId Coin)
bvTotal :: Lens' BalancesView (Maybe Coin)
type UndoMap = HashMap TxId TxUndo
type UtxoModifier = MapModifier TxIn TxOutAux
data GenericToilModifier extension
ToilModifier :: !UtxoModifier -> !BalancesView -> !MemPool -> !UndoMap -> !extension -> GenericToilModifier extension
[_tmUtxo] :: GenericToilModifier extension -> !UtxoModifier
[_tmBalances] :: GenericToilModifier extension -> !BalancesView
[_tmMemPool] :: GenericToilModifier extension -> !MemPool
[_tmUndos] :: GenericToilModifier extension -> !UndoMap
[_tmExtra] :: GenericToilModifier extension -> !extension
type ToilModifier = GenericToilModifier ()
tmUtxo :: forall extension_a1UQd. Lens' (GenericToilModifier extension_a1UQd) UtxoModifier
tmBalances :: forall extension_a1UQd. Lens' (GenericToilModifier extension_a1UQd) BalancesView
tmMemPool :: forall extension_a1UQd. Lens' (GenericToilModifier extension_a1UQd) MemPool
tmUndos :: forall extension_a1UQd. Lens' (GenericToilModifier extension_a1UQd) UndoMap
tmExtra :: forall extension_a1UQd extension_a1USs. Lens (GenericToilModifier extension_a1UQd) (GenericToilModifier extension_a1USs) extension_a1UQd extension_a1USs

-- | Environment used by Toil.
data ToilEnv
ToilEnv :: !Byte -> ToilEnv
[teMaxTxSize] :: ToilEnv -> !Byte

-- | Global context data needed for tx verification. VT stands for "Verify
--   Tx". To be populated in further versions.
data VTxContext
VTxContext :: !Bool -> VTxContext

-- | Verify that script versions in tx are known, addresses' and witnesses'
--   types are known, attributes are known too.
[vtcVerifyAllIsKnown] :: VTxContext -> !Bool

-- | CHECK: Verify Tx correctness using <a>MonadUtxoRead</a>. Specifically
--   there are the following checks:
--   
--   <ul>
--   <li>every input is a known unspent output;</li>
--   <li>sum of inputs &gt;= sum of outputs;</li>
--   <li>every input has a proper witness verifying that input;</li>
--   <li>script witnesses have matching script versions;</li>
--   <li>if <a>vtcVerifyAllIsKnown</a> is <a>True</a>, addresses' versions
--   are verified to be known, as well as witnesses, attributes, script
--   versions.</li>
--   </ul>
--   
--   Note that <a>verifyTxUtxo</a> doesn't attempt to verify scripts with
--   versions higher than maximum script version we can handle. That's
--   because we want blocks with such transactions to be accepted (to avoid
--   hard forks). However, we won't include such transactions into blocks
--   when we're creating a block (because transactions for inclusion into
--   blocks are verified with <a>vtcVerifyAllIsKnown</a> set to
--   <a>True</a>, so unknown script versions are rejected).
verifyTxUtxo :: (MonadUtxoRead m, MonadError ToilVerFailure m) => VTxContext -> TxAux -> m TxUndo

-- | Remove unspent outputs used in given transaction, add new unspent
--   outputs.
applyTxToUtxo :: MonadUtxo m => WithHash Tx -> TxDistribution -> m ()

-- | Rollback application of given transaction to Utxo using Undo data.
--   This function assumes that transaction has been really applied and
--   doesn't check anything.
rollbackTxUtxo :: (MonadUtxo m) => (TxAux, TxUndo) -> m ()
type UtxoReaderT = ReaderT Utxo
runUtxoReaderT :: UtxoReaderT m a -> Utxo -> m a
type UtxoReader = UtxoReaderT Identity
runUtxoReader :: UtxoReader a -> Utxo -> a
type UtxoStateT = StateT Utxo
runUtxoStateT :: UtxoStateT m a -> Utxo -> m (a, Utxo)
evalUtxoStateT :: Monad m => UtxoStateT m a -> Utxo -> m a
execUtxoStateT :: Monad m => UtxoStateT m a -> Utxo -> m Utxo
type UtxoState = UtxoStateT Identity
runUtxoState :: UtxoState a -> Utxo -> (a, Utxo)
evalUtxoState :: UtxoState a -> Utxo -> a
execUtxoState :: UtxoState a -> Utxo -> Utxo

-- | Pure version of applyTxToUtxo.
applyTxToUtxoPure :: WithHash Tx -> TxDistribution -> Utxo -> Utxo

-- | Pure version of verifyTxUtxo.
verifyTxUtxoPure :: MonadError ToilVerFailure m => VTxContext -> Utxo -> TxAux -> m TxUndo

-- | Select only TxOuts for given addresses
filterUtxoByAddr :: Address -> Utxo -> Utxo

-- | Convert <a>Utxo</a> to map from <a>StakeholderId</a> to stake.
utxoToStakes :: Utxo -> HashMap StakeholderId Coin

module Pos.Client.Txp.Balances

-- | A class which have the methods to get state of address' balance
class Monad m => MonadBalances m where getOwnUtxo = lift . getOwnUtxo getBalance = lift . getBalance
getOwnUtxo :: MonadBalances m => Address -> m Utxo
getBalance :: MonadBalances m => Address -> m Coin
getOwnUtxo :: (MonadBalances m, MonadTrans t, MonadBalances m', t m' ~ m) => Address -> m Utxo
getBalance :: (MonadBalances m, MonadTrans t, MonadBalances m', t m' ~ m) => Address -> m Coin
getBalanceFromUtxo :: MonadBalances m => Address -> m Coin
instance (Pos.Client.Txp.Balances.MonadBalances m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Pos.Client.Txp.Balances.MonadBalances (t m)
instance (Pos.DB.Class.MonadDB m, Control.Monad.Catch.MonadMask m, System.Wlog.CanLog.WithLogger m) => Pos.Client.Txp.Balances.MonadBalances (Pos.Txp.MemState.Holder.TxpHolder __ m)

module Pos.Client.Txp.History

-- | Datatype for returning info about tx history
data TxHistoryEntry
THEntry :: !TxId -> !Tx -> !Bool -> ![TxOut] -> !(Maybe ChainDifficulty) -> TxHistoryEntry
[_thTxId] :: TxHistoryEntry -> !TxId
[_thTx] :: TxHistoryEntry -> !Tx
[_thIsOutput] :: TxHistoryEntry -> !Bool
[_thInputs] :: TxHistoryEntry -> ![TxOut]
[_thDifficulty] :: TxHistoryEntry -> !(Maybe ChainDifficulty)
thTxId :: Lens' TxHistoryEntry TxId
thTx :: Lens' TxHistoryEntry Tx
thIsOutput :: Lens' TxHistoryEntry Bool
thInputs :: Lens' TxHistoryEntry [TxOut]
thDifficulty :: Lens' TxHistoryEntry (Maybe ChainDifficulty)
data TxHistoryAnswer
TxHistoryAnswer :: HeaderHash -> Int -> Utxo -> [TxHistoryEntry] -> TxHistoryAnswer
[taLastCachedHash] :: TxHistoryAnswer -> HeaderHash
[taCachedNum] :: TxHistoryAnswer -> Int
[taCachedUtxo] :: TxHistoryAnswer -> Utxo
[taHistory] :: TxHistoryAnswer -> [TxHistoryEntry]

-- | A class which have methods to get transaction history
class Monad m => MonadTxHistory m where getTxHistory = fmap lift <<$>> getTxHistory saveTx = lift . saveTx
getTxHistory :: (MonadTxHistory m, SscHelpersClass ssc) => Tagged ssc (Address -> Maybe (HeaderHash, Utxo) -> m TxHistoryAnswer)
saveTx :: MonadTxHistory m => (TxId, TxAux) -> m ()
getTxHistory :: (MonadTxHistory m, SscHelpersClass ssc, MonadTrans t, MonadTxHistory m', t m' ~ m) => Tagged ssc (Address -> Maybe (HeaderHash, Utxo) -> m TxHistoryAnswer)
saveTx :: (MonadTxHistory m, MonadTrans t, MonadTxHistory m', t m' ~ m) => (TxId, TxAux) -> m ()

-- | Select transactions related to given address. <a>Bool</a> indicates
--   whether the transaction is outgoing (i. e. is sent from given address)
getRelatedTxs :: Monad m => Address -> [(WithHash Tx, TxWitness, TxDistribution)] -> TxSelectorT m [TxHistoryEntry]

-- | Given a full blockchain, derive address history and Utxo TODO: Such
--   functionality will still be useful for merging blockchains when wallet
--   state is ready, but some metadata for Tx will be required.
deriveAddrHistory :: (Monad m) => Address -> [Block ssc] -> TxSelectorT m [TxHistoryEntry]
deriveAddrHistoryPartial :: (Monad m) => [TxHistoryEntry] -> Address -> [Block ssc] -> TxSelectorT m [TxHistoryEntry]
instance (Pos.Client.Txp.History.MonadTxHistory m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Pos.Client.Txp.History.MonadTxHistory (t m)
instance (Pos.DB.Class.MonadDB m, Control.Monad.Catch.MonadThrow m, System.Wlog.CanLog.WithLogger m, Pos.Slotting.Class.MonadSlots m, Pos.Context.Class.WithNodeContext s m) => Pos.Client.Txp.History.MonadTxHistory (Pos.Txp.MemState.Holder.TxpHolder Pos.WorkMode.TxpExtra_TMP m)
instance GHC.Show.Show Pos.Client.Txp.History.TxHistoryAnswer
instance GHC.Generics.Generic Pos.Client.Txp.History.TxHistoryEntry
instance GHC.Classes.Eq Pos.Client.Txp.History.TxHistoryEntry
instance GHC.Show.Show Pos.Client.Txp.History.TxHistoryEntry


-- | Pure functions for operations with transactions
module Pos.Client.Txp.Util

-- | Makes a transaction which use P2PKH addresses as a source
makePubKeyTx :: SafeSigner -> TxInputs -> TxOutputs -> TxAux
makeMOfNTx :: Script -> [Maybe SafeSigner] -> TxInputs -> TxOutputs -> TxAux
makeRedemptionTx :: RedeemSecretKey -> TxInputs -> TxOutputs -> TxAux

-- | Make a multi-transaction using given secret key and info for outputs
createTx :: Utxo -> SafeSigner -> TxOutputs -> Either TxError TxAux

-- | Make a transaction, using M-of-N script as a source
createMOfNTx :: Utxo -> [(PublicKey, Maybe SafeSigner)] -> TxOutputs -> Either TxError TxAux
createRedemptionTx :: Utxo -> RedeemSecretKey -> TxOutputs -> Either TxError TxAux
type TxError = Text


-- | Explorer functionality (to be moved into cryptokami-explorer).
module Pos.Explorer
data TxExtra
TxExtra :: !(Maybe (HeaderHash, Word32)) -> !Timestamp -> NonEmpty TxOutAux -> TxExtra
[teBlockchainPlace] :: TxExtra -> !(Maybe (HeaderHash, Word32))
[teReceivedTime] :: TxExtra -> !Timestamp
[teInputOutputs] :: TxExtra -> NonEmpty TxOutAux
type AddrHistory = NewestFirst [] TxId
data TxExtra
TxExtra :: !(Maybe (HeaderHash, Word32)) -> !Timestamp -> NonEmpty TxOutAux -> TxExtra
[teBlockchainPlace] :: TxExtra -> !(Maybe (HeaderHash, Word32))
[teReceivedTime] :: TxExtra -> !Timestamp
[teInputOutputs] :: TxExtra -> NonEmpty TxOutAux
type AddrHistory = NewestFirst [] TxId
data ExplorerOp
AddTxExtra :: !TxId -> !TxExtra -> ExplorerOp
DelTxExtra :: !TxId -> ExplorerOp
UpdateAddrHistory :: !Address -> !AddrHistory -> ExplorerOp
getTxExtra :: MonadDB m => TxId -> m (Maybe TxExtra)
getAddrHistory :: MonadDB m => Address -> m AddrHistory

-- | Settings used for global transactions data processing used by
--   explorer.
explorerTxpGlobalSettings :: TxpGlobalSettings
eTxProcessTransaction :: ETxpLocalWorkMode m => (TxId, TxAux) -> m ()

-- | <ol>
--   <li>Recompute UtxoView by current MemPool | 2. Remove invalid
--   transactions from MemPool | 3. Set new tip to txp local data</li>
--   </ol>
eTxNormalize :: (MonadDB m, MonadTxpMem ExplorerExtra m) => m ()
class MonadTxExtraRead m => MonadTxExtra m where putTxExtra id = lift . putTxExtra id delTxExtra = lift . delTxExtra updateAddrHistory addr = lift . updateAddrHistory addr
putTxExtra :: MonadTxExtra m => TxId -> TxExtra -> m ()
delTxExtra :: MonadTxExtra m => TxId -> m ()
updateAddrHistory :: MonadTxExtra m => Address -> AddrHistory -> m ()
putTxExtra :: (MonadTxExtra m, MonadTrans t, MonadTxExtra m', t m' ~ m) => TxId -> TxExtra -> m ()
delTxExtra :: (MonadTxExtra m, MonadTrans t, MonadTxExtra m', t m' ~ m) => TxId -> m ()
updateAddrHistory :: (MonadTxExtra m, MonadTrans t, MonadTxExtra m', t m' ~ m) => Address -> AddrHistory -> m ()
class Monad m => MonadTxExtraRead m where getTxExtra = lift . getTxExtra getAddrHistory = lift . getAddrHistory
getTxExtra :: MonadTxExtraRead m => TxId -> m (Maybe TxExtra)
getAddrHistory :: MonadTxExtraRead m => Address -> m AddrHistory
getTxExtra :: (MonadTxExtraRead m, MonadTrans t, MonadTxExtraRead m', t m' ~ m) => TxId -> m (Maybe TxExtra)
getAddrHistory :: (MonadTxExtraRead m, MonadTrans t, MonadTxExtraRead m', t m' ~ m) => Address -> m AddrHistory
type EGlobalToilMode m = (GlobalToilMode m, MonadTxExtra m)

-- | Apply transactions from one block. They must be valid (for example, it
--   implies topological sort).
eApplyToil :: EGlobalToilMode m => Timestamp -> [(TxAux, TxUndo)] -> HeaderHash -> m ()

-- | Rollback transactions from one block.
eRollbackToil :: EGlobalToilMode m => [(TxAux, TxUndo)] -> m ()

-- | Get rid of invalid transactions. All valid transactions will be added
--   to mem pool and applied to utxo.
eNormalizeToil :: (ELocalToilMode m) => [(TxId, (TxAux, TxExtra))] -> m ()

-- | Verify one transaction and also add it to mem pool and apply to utxo
--   if transaction is valid.
eProcessTx :: (ELocalToilMode m, MonadError ToilVerFailure m) => (TxId, TxAux) -> TxExtra -> m ()
data ExplorerExtra
ExplorerExtra :: !TxMapExtra -> !UpdatedAddrHistories -> ExplorerExtra
[_eeLocalTxsExtra] :: ExplorerExtra -> !TxMapExtra
[_eeAddrHistories] :: ExplorerExtra -> !UpdatedAddrHistories
type EToilModifier = GenericToilModifier ExplorerExtra
eeLocalTxsExtra :: Lens' ExplorerExtra TxMapExtra
eeAddrHistories :: Lens' ExplorerExtra UpdatedAddrHistories
data ExplorerExtra
ExplorerExtra :: !TxMapExtra -> !UpdatedAddrHistories -> ExplorerExtra
[_eeLocalTxsExtra] :: ExplorerExtra -> !TxMapExtra
[_eeAddrHistories] :: ExplorerExtra -> !UpdatedAddrHistories
type EToilModifier = GenericToilModifier ExplorerExtra
eeLocalTxsExtra :: Lens' ExplorerExtra TxMapExtra
eeAddrHistories :: Lens' ExplorerExtra UpdatedAddrHistories


-- | Web-related part of cryptokami-sl.
module Pos.Web
baseDocsText :: Text
gtDocsText :: Text
type MyWorkMode ssc m = (WorkMode ssc m, SscConstraint ssc)
type WebHandler ssc = TxpHolder TxpExtra_TMP (DBHolder (ContextHolder ssc Production))
serveImpl :: MonadIO m => m Application -> String -> Word16 -> m ()
nat :: forall ssc m. (MyWorkMode ssc m) => m (WebHandler ssc :~> Handler)
serveWebBase :: MyWorkMode ssc m => Word16 -> m ()
applicationBase :: MyWorkMode ssc m => m Application
serveWebGT :: MyWorkMode SscGodTossing m => Word16 -> m ()
applicationGT :: MyWorkMode SscGodTossing m => m Application


-- | Whole Update System in one module :)
module Pos.Update

-- | Download and save archive update by given
--   <a>ConfirmedProposalState</a>
downloadUpdate :: UpdateMode m => ConfirmedProposalState -> m ()

-- | Download a file by its hash.
--   
--   Tries all servers in turn, fails if none of them work.
downloadHash :: [Text] -> Hash LByteString -> IO (Either Text LByteString)

-- | Apply chain of <i>definitely</i> valid blocks to US part of GState DB
--   and to US local data. This function assumes that no other thread
--   applies block in parallel. It also assumes that parent of oldest block
--   is current tip. If verification is done prior to application, one can
--   pass <a>PollModifier</a> obtained from verification to this function.
usApplyBlocks :: (MonadThrow m, USGlobalApplyMode m) => OldestFirst NE UpdateBlock -> Maybe PollModifier -> m [SomeBatchOp]

-- | Checks whether our software can create block according to current
--   global state.
usCanCreateBlock :: (WithLogger m, MonadDB m, HasContext LrcContext m) => m Bool

-- | Revert application of given blocks to US part of GState DB and US
--   local data. The caller must ensure that the tip stored in DB is
--   <tt>headerHash</tt> of head.
usRollbackBlocks :: forall m. USGlobalApplyMode m => NewestFirst NE (UpdateBlock, USUndo) -> m [SomeBatchOp]

-- | Verify whether sequence of blocks can be applied to US part of current
--   GState DB. This function doesn't make pure checks, they are assumed to
--   be done earlier, most likely during objects construction.
--   
--   If the first argument is <a>True</a> it means that all data must be
--   known. Currently it only means that <tt>UpdateProposal</tt>s must have
--   only known attributes, but I can't guarantee this comment will always
--   be up-to-date.
usVerifyBlocks :: (USGlobalVerifyMode m) => Bool -> OldestFirst NE UpdateBlock -> m (PollModifier, OldestFirst NE USUndo)

-- | This function returns true if update proposal with given identifier
--   should be requested.
isProposalNeeded :: (HasContext UpdateContext m, MonadIO m) => UpId -> m Bool

-- | Get update proposal with given id if it is known.
getLocalProposalNVotes :: (HasContext UpdateContext m, MonadIO m) => UpId -> m (Maybe (UpdateProposal, [UpdateVote]))

-- | Process proposal received from network, checking it against current
--   state (global + local) and adding to local state if it's valid with
--   respect to it. If proposal is added to store, 'Right ()' is returned.
--   Otherwise 'Left err' is returned and <tt>err</tt> lets caller decide
--   whether sender could be sure that error would happen.
processProposal :: (USLocalLogicMode m) => UpdateProposal -> m (Either PollVerFailure ())

-- | This function returns true if update vote proposal with given
--   identifier issued by stakeholder with given PublicKey and with given
--   decision should be requested.
isVoteNeeded :: USLocalLogicMode m => UpId -> PublicKey -> Bool -> m Bool

-- | Get update vote for proposal with given id from given issuer and with
--   given decision if it is known.
getLocalVote :: (HasContext UpdateContext m, MonadIO m) => UpId -> PublicKey -> Bool -> m (Maybe UpdateVote)

-- | Process vote received from network, checking it against current state
--   (global + local) and adding to local state if it's valid with respect
--   to it. If vote is added to store, 'Right ()' is returned. Otherwise
--   'Left err' is returned and <tt>err</tt> lets caller decide whether
--   sender could be sure that error would happen.
processVote :: (USLocalLogicMode m) => UpdateVote -> m (Either PollVerFailure ())

-- | Remove local data from memory state to make it consistent with current
--   GState. This function assumes that GState is locked. It tries to leave
--   as much data as possible. It assumes that <tt>blkSemaphore</tt> is
--   taken.
usNormalize :: (USLocalLogicMode m) => m ()

-- | Update memory state to make it correct for given slot.
processNewSlot :: (USLocalLogicMode m) => SlotId -> m ()

-- | Prepare UpdatePayload for inclusion into new block with given SlotId.
--   This function assumes that <tt>blkSemaphore</tt> is taken and nobody
--   can apply/rollback blocks in parallel. Sometimes payload can't be
--   created. It can happen if we are trying to create block for slot which
--   has already passed, for example.
usPreparePayload :: (USLocalLogicMode m) => SlotId -> m (Maybe UpdatePayload)
clearUSMemPool :: (HasContext UpdateContext m, MonadIO m) => m ()

-- | Consumer will be called on every Richmen computation.
usLrcConsumer :: MonadDBCore m => LrcConsumer m

-- | Listeners for requests related to update system
usListeners :: (UpdateMode m) => m ([ListenerSpec m], OutSpecs)
usStubListeners :: (WithLogger m) => ([ListenerSpec m], OutSpecs)

-- | Tag for proposal messages
data ProposalMsgTag
ProposalMsgTag :: ProposalMsgTag

-- | Tag for vote messages
data VoteMsgTag
VoteMsgTag :: VoteMsgTag

-- | Update System related workers.
usWorkers :: WorkMode ssc m => ([WorkerSpec m], OutSpecs)


-- | Module for exposing JSON instances for Cryptokami types
module Pos.Aeson

module Pos.Delegation

-- | In-memory storage needed for delegation logic Maybe ncProxyCache
--   should be LRU instead of hashmap, but that's not urgent optimization
--   idea.
data DelegationWrap
DelegationWrap :: HashMap SendProxySK UTCTime -> HashMap ProxySKLight UTCTime -> HashMap PublicKey ProxySKHeavy -> EpochIndex -> HashSet PublicKey -> DelegationWrap

-- | Message cache to prevent infinite propagation of useless certs.
[_dwMessageCache] :: DelegationWrap -> HashMap SendProxySK UTCTime

-- | Confirmation cache for lightweight PSKs.
[_dwConfirmationCache] :: DelegationWrap -> HashMap ProxySKLight UTCTime

-- | Memory pool of hardweight proxy secret keys. Keys of this map are
--   issuer public keys.
[_dwProxySKPool] :: DelegationWrap -> HashMap PublicKey ProxySKHeavy

-- | Epoch index <a>DelegationWrap</a> is correct in relation to.
[_dwEpochId] :: DelegationWrap -> EpochIndex

-- | Set of stakeholders that have already posted their PSKs this epoch.
[_dwThisEpochPosted] :: DelegationWrap -> HashSet PublicKey
dwMessageCache :: Lens' DelegationWrap (HashMap SendProxySK UTCTime)
dwConfirmationCache :: Lens' DelegationWrap (HashMap ProxySKLight UTCTime)
dwProxySKPool :: Lens' DelegationWrap (HashMap PublicKey ProxySKHeavy)
dwEpochId :: Lens' DelegationWrap EpochIndex
dwThisEpochPosted :: Lens' DelegationWrap (HashSet PublicKey)

-- | Equivalent of <tt>MonadReader (TVar DelegationWrap) m</tt>. Currently
--   we're locking on the whole delegation wrap at once. Locking on
--   independent components is better in performance, so there's a place
--   for optimization here.
type MonadDelegation = MonadReader (TVar DelegationWrap)
askDelegationState :: MonadDelegation m => m (TVar DelegationWrap)

-- | Retrieves certificate by issuer address (hash of public key) if
--   present.
getPSKByIssuerAddressHash :: MonadDB m => StakeholderId -> m (Maybe ProxySKHeavy)

-- | Retrieves certificate by issuer public key if present.
getPSKByIssuer :: MonadDB m => PublicKey -> m (Maybe ProxySKHeavy)
isIssuerByAddressHash :: MonadDB m => StakeholderId -> m Bool
data DelegationOp

-- | Adds PSK. Overwrites if present.
AddPSK :: !ProxySKHeavy -> DelegationOp

-- | Removes PSK by issuer PK.
DelPSK :: !PublicKey -> DelegationOp
runPskIterator :: forall m a. MonadDB m => DBnIterator PskIter a -> m a
runPskMapIterator :: forall v m a. MonadDB m => DBnMapIterator PskIter v a -> (IterType PskIter -> v) -> m a

-- | Wrapper of <tt>ReaderT (TVar DelegationWrap)</tt>, nothing smart.
type DelegationT = ReaderT (TVar DelegationWrap)

-- | Executes delegationT transformer creating tvar from given wrap.
runDelegationT :: MonadIO m => DelegationWrap -> DelegationT m a -> m a

-- | Executes delegation wrap using existing delegation wrap tvar.
runDelegationTFromTVar :: TVar DelegationWrap -> DelegationT m a -> m a

-- | Listeners for requests related to delegation processing.
delegationListeners :: WorkMode ssc m => ([ListenerSpec m], OutSpecs)
delegationStubListeners :: WithLogger m => ([ListenerSpec m], OutSpecs)

-- | Handler <a>SendProxySK</a> event.
handleSendProxySK :: forall ssc m. (WorkMode ssc m) => (ListenerSpec m, OutSpecs)
handleConfirmProxySK :: forall ssc m. (WorkMode ssc m) => (ListenerSpec m, OutSpecs)

-- | Convenient monad to work in <a>DelegationWrap</a> context while being
--   in STM.
type DelegationStateAction = StateT DelegationWrap STM

-- | Effectively takes a lock on ProxyCaches mvar in NodeContext and allows
--   you to run some computation producing updated ProxyCaches and return
--   value. Will put MVar back on exception.
runDelegationStateAction :: (MonadIO m, MonadDelegation m) => DelegationStateAction a -> m a

-- | Invalidates proxy caches using built-in constants.
invalidateProxyCaches :: UTCTime -> DelegationStateAction ()

-- | Initializes delegation in-memory storage.
--   
--   <ul>
--   <li>Sets <a>_dwEpochId</a> to epoch of tip.</li>
--   <li>Loads <a>_dwThisEpochPosted</a> from database</li>
--   </ul>
initDelegation :: forall ssc m. (SscHelpersClass ssc, MonadDB m, MonadDelegation m) => m ()

-- | Retrieves current mempool of heavyweight psks plus undo part.
getProxyMempool :: (MonadDB m, MonadDelegation m) => m ([ProxySKHeavy], [ProxySKHeavy])
clearProxyMemPool :: (MonadDB m, MonadDelegation m) => m ()

-- | Datatypes representing a verdict of heavy PSK processing.
data PskHeavyVerdict

-- | If we have exactly the same cert in psk mempool
PHExists :: PskHeavyVerdict

-- | Can't accept PSK though it's most probably user's error
PHInvalid :: Text -> PskHeavyVerdict

-- | Broken (signature, most probably attack, we can ban for this)
PHBroken :: PskHeavyVerdict

-- | Message is cached
PHCached :: PskHeavyVerdict

-- | Verdict can't be made at the moment (we're updating)
PHIncoherent :: PskHeavyVerdict

-- | Successfully processed/added to psk mempool
PHAdded :: PskHeavyVerdict

-- | Processes heavyweight psk. Puts it into the mempool depending on
--   issuer's stake, overrides if exists, checks validity and cachemsg
--   state.
processProxySKHeavy :: forall ssc m. (SscHelpersClass ssc, MonadDB m, MonadDelegation m, HasContext LrcContext m) => ProxySKHeavy -> m PskHeavyVerdict

-- | Applies a sequence of definitely valid blocks to memory state and
--   returns batchops. It works correctly only in case blocks don't cross
--   over epoch. So genesis block is either absent or the head.
delegationApplyBlocks :: forall ssc m. (DelegationWorkMode m) => OldestFirst NE (Block ssc) -> m (NonEmpty SomeBatchOp)

-- | Verifies if blocks are correct relatively to the delegation logic and
--   returns a non-empty list of proxySKs needed for undoing them.
--   Predicate for correctness here is:
--   
--   <ul>
--   <li>Issuer can post only one cert per epoch</li>
--   <li>For every new certificate issuer had enough stake at the end of
--   prev. epoch</li>
--   </ul>
--   
--   It's assumed blocks are correct from 'Pos.Types.Block#verifyBlocks'
--   point of view.
delegationVerifyBlocks :: forall ssc m. (SscHelpersClass ssc, MonadDB m, HasContext LrcContext m) => OldestFirst NE (Block ssc) -> m (Either Text (OldestFirst NE [ProxySKHeavy]))

-- | Rollbacks block list. Erases mempool of certificates. Better to
--   restore them after the rollback (see Txp#normalizeTxpLD). You can
--   rollback arbitrary number of blocks.
delegationRollbackBlocks :: forall ssc m. (SscHelpersClass ssc, MonadDelegation m, MonadDB m, HasContext LrcContext m) => NewestFirst NE (Blund ssc) -> m (NonEmpty SomeBatchOp)

-- | PSK check verdict. It can be unrelated (other key or spoiled, no way
--   to differ), exist in storage already or be cached.
data PskLightVerdict
PLUnrelated :: PskLightVerdict
PLInvalid :: PskLightVerdict
PLExists :: PskLightVerdict
PLCached :: PskLightVerdict
PLRemoved :: PskLightVerdict
PLAdded :: PskLightVerdict

-- | Processes proxy secret key (understands do we need it, adds/caches on
--   decision, returns this decision).
processProxySKLight :: (MonadDelegation m, WithNodeContext ssc m, MonadDB m, MonadMask m) => ProxySKLight -> m PskLightVerdict

-- | Verdict of <a>processConfirmProxySk</a> function
data ConfirmPskLightVerdict

-- | Valid, saved
CPValid :: ConfirmPskLightVerdict

-- | Invalid, throw away
CPInvalid :: ConfirmPskLightVerdict

-- | Already saved
CPCached :: ConfirmPskLightVerdict

-- | Takes a lightweight psk, delegate proof of delivery. Checks if it's
--   valid or not. Caches message in any case.
processConfirmProxySk :: (MonadDelegation m, MonadIO m) => ProxySKLight -> ProxySigLight ProxySKLight -> m ConfirmPskLightVerdict

-- | Checks if we hold a confirmation for given PSK.
isProxySKConfirmed :: ProxySKLight -> DelegationStateAction Bool

-- | Consumer will be called on every Richmen computation.
delegationLrcConsumer :: MonadDBCore m => LrcConsumer m

-- | Sends epoch psk to neighbours
sendProxySKLight :: (MinWorkMode m, MonadDiscovery m) => ProxySKLight -> Action' m ()

-- | Sends simple psk to neighbours
sendProxySKHeavy :: (MinWorkMode m, MonadDiscovery m) => ProxySKHeavy -> Action' m ()

-- | Generates a proof of being a delegate for psk and sends it to
--   neighbors.
sendProxyConfirmSK :: (WorkMode ssc m) => ProxySKLight -> Action' m ()
sendProxySKLightOuts :: OutSpecs
sendProxySKHeavyOuts :: OutSpecs
sendProxyConfirmSKOuts :: OutSpecs

-- | Message with delegated proxy secret key. Is used to propagate both
--   epoch-oriented psks (lightweight) and simple (heavyweight).
data SendProxySK
SendProxySKLight :: !ProxySKLight -> SendProxySK
SendProxySKHeavy :: !ProxySKHeavy -> SendProxySK

-- | Confirmation of proxy signature delivery. Delegate should take the
--   proxy signing key he has and sign this key with itself. If the
--   signature is correct, then it was done by delegate (guaranteed by PSK
--   scheme). Checking <tt>w</tt> can be done with <tt>(const True)</tt>
--   predicate, because certificate may be sent in epoch id that's before
--   lower cert's <tt>EpochIndex</tt>.
data ConfirmProxySK
ConfirmProxySK :: !ProxySKLight -> !(ProxySigLight ProxySKLight) -> ConfirmProxySK

-- | All workers specific to proxy sertificates processing.
dlgWorkers :: (WorkMode ssc m) => ([WorkerSpec m], OutSpecs)


-- | Logic of blocks processing.
module Pos.Block.Logic

-- | Find LCA of headers list and main chain, including oldest header's
--   parent hash. Iterates from newest to oldest until meets first header
--   that's in main chain. O(n).
lcaWithMainChain :: (WorkMode ssc m) => OldestFirst NE (BlockHeader ssc) -> m (Maybe HeaderHash)

-- | Common error message
tipMismatchMsg :: Text -> HeaderHash -> HeaderHash -> Text

-- | Run action acquiring lock on block application. Argument of action is
--   an old tip, result is put as a new tip.
withBlkSemaphore :: WorkMode ssc m => (HeaderHash -> m (a, HeaderHash)) -> m a

-- | Version of withBlkSemaphore which doesn't have any result.
withBlkSemaphore_ :: WorkMode ssc m => (HeaderHash -> m HeaderHash) -> m ()

-- | The phrase “we're in recovery mode” is confusing because it can mean
--   two different things:
--   
--   <ol>
--   <li>Last known block is more than K slots away from the current slot,
--   or current slot isn't known.</li>
--   <li>We're actually in the process of requesting blocks because we have
--   detected that #1 happened. (See <tt>ncRecoveryHeader</tt> and
--   <tt>recoveryInProgress</tt>.)</li>
--   </ol>
--   
--   This function checks for #1. Note that even if we're doing recovery
--   right now, <a>needRecovery</a> will still return <a>True</a>.
needRecovery :: forall ssc m. WorkMode ssc m => m Bool

-- | Result of single (new) header classification.
data ClassifyHeaderRes

-- | Header is direct continuation of main chain (i.e. its parent is our
--   tip).
CHContinues :: ClassifyHeaderRes

-- | Header continues main or alternative chain, it's more difficult than
--   tip.
CHAlternative :: ClassifyHeaderRes

-- | Header is useless.
CHUseless :: !Text -> ClassifyHeaderRes

-- | Header is invalid.
CHInvalid :: !Text -> ClassifyHeaderRes

-- | Classify new header announced by some node. Result is represented as
--   ClassifyHeaderRes type.
classifyNewHeader :: (WorkMode ssc m) => BlockHeader ssc -> m ClassifyHeaderRes

-- | Result of multiple headers classification.
data ClassifyHeadersRes ssc

-- | Header list can be applied, LCA child attached.
CHsValid :: (BlockHeader ssc) -> ClassifyHeadersRes ssc

-- | Header is useless.
CHsUseless :: !Text -> ClassifyHeadersRes ssc

-- | Header is invalid.
CHsInvalid :: !Text -> ClassifyHeadersRes ssc

-- | Classify headers received in response to <tt>GetHeaders</tt> message.
--   
--   <ul>
--   <li>If there are any errors in chain of headers, CHsInvalid is
--   returned.</li>
--   <li>If chain of headers is a valid continuation or alternative branch,
--   lca child is returned.</li>
--   <li>If chain of headers forks from our main chain too much, CHsUseless
--   is returned, because paper suggests doing so.</li>
--   <li>CHsUseless is also returned if we aren't too far behind the
--   current slot (i.e. if <a>needRecovery</a> is false) but the newest
--   header in the list isn't from the current slot. See CSL-177.</li>
--   </ul>
classifyHeaders :: forall ssc m. WorkMode ssc m => NewestFirst NE (BlockHeader ssc) -> m (ClassifyHeadersRes ssc)

-- | Given a set of checkpoints <tt>c</tt> to stop at and a terminating
--   header hash <tt>h</tt>, we take <tt>h</tt> block (or tip if latter is
--   <tt>Nothing</tt>) and fetch the blocks until one of checkpoints is
--   encountered. In case we got deeper than <a>recoveryHeadersMessage</a>,
--   we return <a>recoveryHeadersMessage</a> headers starting from the the
--   newest checkpoint that's in our main chain to the newest ones.
getHeadersFromManyTo :: forall ssc m. (MonadDB m, SscHelpersClass ssc, CanLog m, HasLoggerName m) => NonEmpty HeaderHash -> Maybe HeaderHash -> m (Either Text (NewestFirst NE (BlockHeader ssc)))

-- | Given a starting point hash (we take tip if it's not in storage) it
--   returns not more than <a>blkSecurityParam</a> blocks distributed
--   exponentially base 2 relatively to the depth in the blockchain.
getHeadersOlderExp :: forall ssc m. (MonadDB m, SscHelpersClass ssc) => Maybe HeaderHash -> m (OldestFirst [] HeaderHash)

-- | Given <tt>from</tt> and <tt>to</tt> headers where <tt>from</tt> is
--   older (not strict) than <tt>to</tt>, and valid chain in between can be
--   found, headers in range <tt>[from..to]</tt> will be found.
getHeadersFromToIncl :: forall ssc m. (MonadDB m, SscHelpersClass ssc) => HeaderHash -> HeaderHash -> m (Maybe (OldestFirst NE HeaderHash))

-- | Applies blocks if they're valid. Takes one boolean flag "rollback".
--   Returns header hash of last applied block (new tip) on success.
--   Failure behaviour depends on "rollback" flag. If it's on, all blocks
--   applied inside this function will be rollbacked, so it will do
--   effectively nothing and return 'Left error'. If it's off, it will try
--   to apply as much blocks as it's possible and return header hash of new
--   tip. It's up to caller to log warning that partial application
--   happened.
verifyAndApplyBlocks :: (MonadDBCore m, WorkMode ssc m, SscWorkersClass ssc) => Bool -> OldestFirst NE (Block ssc) -> m (Either Text HeaderHash)

-- | Rollbacks blocks. Head must be the current tip.
rollbackBlocks :: (WorkMode ssc m) => NewestFirst NE (Blund ssc) -> m (Maybe Text)

-- | Rollbacks some blocks and then applies some blocks.
applyWithRollback :: (MonadDBCore m, WorkMode ssc m, SscWorkersClass ssc) => NewestFirst NE (Blund ssc) -> OldestFirst NE (Block ssc) -> m (Either Text HeaderHash)

-- | Create genesis block if necessary.
--   
--   We create genesis block for current epoch when head of currently known
--   best chain is MainBlock corresponding to one of last
--   <a>slotSecurityParam</a> slots of (i - 1)-th epoch. Main check is that
--   epoch is `(last stored epoch + 1)`, but we also don't want to create
--   genesis block on top of blocks from previous epoch which are not from
--   last slotSecurityParam slots, because it's practically impossible for
--   them to be valid. [CSL-481] We can do consider doing it though.
createGenesisBlock :: forall ssc m. WorkMode ssc m => EpochIndex -> m (Maybe (GenesisBlock ssc))

-- | Create a new main block on top of best chain if possible. Block can be
--   created if: • we know genesis block for epoch from given SlotId • last
--   known block is not more than <a>slotSecurityParam</a> blocks away from
--   given SlotId
createMainBlock :: forall ssc m. (WorkMode ssc m) => SlotId -> Maybe ProxySKEither -> m (Either Text (MainBlock ssc))
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Block.Logic.ClassifyHeadersRes ssc)
instance GHC.Show.Show Pos.Block.Logic.ClassifyHeaderRes


-- | Re-exports of Pos.Communication.*
module Pos.Communication


-- | Module for command-line utilites, parsers and convenient handlers.
module Pos.CLI

-- | Parsed for network address in format <tt>host:port</tt>.
addrParser :: Parser NetworkAddress
attackTypeParser :: Parser AttackType
attackTargetParser :: Parser AttackTarget

-- | Default logger config. Will be used if `--log-config` argument is not
--   passed. Corresponds to next logger config:
--   
--   <pre>
--   node:
--     severity: Info
--     comm:
--       severity: Warning
--   </pre>
defaultLoggerConfig :: LoggerConfig

-- | Reads logger config from given path. By default return
--   <a>defaultLoggerConfig</a>.
readLoggerConfig :: MonadIO m => Maybe FilePath -> m LoggerConfig

-- | Decides which secret-sharing algorithm to use.
sscAlgoParser :: Parser SscAlgo
data CommonArgs
CommonArgs :: !(Maybe FilePath) -> !(Maybe FilePath) -> !SscAlgo -> !Bool -> ![Text] -> ![Text] -> !(Maybe (Int, Int)) -> !(Maybe (Int, Int)) -> !(Maybe (Int, Int, Integer, Double)) -> !Bool -> !Timestamp -> !PeerId -> CommonArgs
[logConfig] :: CommonArgs -> !(Maybe FilePath)
[logPrefix] :: CommonArgs -> !(Maybe FilePath)
[sscAlgo] :: CommonArgs -> !SscAlgo
[disablePropagation] :: CommonArgs -> !Bool
[reportServers] :: CommonArgs -> ![Text]
[updateServers] :: CommonArgs -> ![Text]
[flatDistr] :: CommonArgs -> !(Maybe (Int, Int))
[bitcoinDistr] :: CommonArgs -> !(Maybe (Int, Int))
[richPoorDistr] :: CommonArgs -> !(Maybe (Int, Int, Integer, Double))
[expDistr] :: CommonArgs -> !Bool

-- | The system start time.
[sysStart] :: CommonArgs -> !Timestamp

-- | A node's peer identifier.
[peerId] :: CommonArgs -> !PeerId
commonArgsParser :: Parser CommonArgs
optionalJSONPath :: Parser (Maybe FilePath)
optionalLogPrefix :: Parser (Maybe String)
portOption :: Word16 -> Parser Word16
timeLordOption :: Parser Bool
webPortOption :: Word16 -> String -> Parser Word16
walletPortOption :: Word16 -> String -> Parser Word16
networkAddressOption :: String -> String -> Parser NetworkAddress
externalNetworkAddressOption :: Maybe NetworkAddress -> Parser NetworkAddress
listenNetworkAddressOption :: Maybe NetworkAddress -> Parser NetworkAddress
sysStartOption :: Parser Timestamp
peerIdOption :: Parser PeerId
nodeIdOption :: String -> String -> Parser NodeId
instance GHC.Show.Show Pos.CLI.CommonArgs

module Pos.Block.Network
announceBlock :: WorkMode ssc m => SendActions m -> MainBlockHeader ssc -> m ()
announceBlockOuts :: OutSpecs
handleHeadersCommunication :: forall ssc m s. (WorkMode ssc m, Reifies s (Limit MsgGetHeaders)) => ConversationActions (MsgHeaders ssc) (LimitedLength s MsgGetHeaders) m -> Proxy s -> m ()
blockListeners :: (SscWorkersClass ssc, WorkMode ssc m) => m ([ListenerSpec m], OutSpecs)
blockStubListeners :: (SscHelpersClass ssc, WithLogger m) => Tagged ssc ([ListenerSpec m], OutSpecs)

-- | Start recovery based on established communication. “Starting recovery”
--   means simply sending all our neighbors a <a>MsgGetHeaders</a> message
--   (see <a>requestTip</a>), so sometimes <a>triggerRecovery</a> is used
--   simply to ask for tips (e.g. in <tt>queryBlocksWorker</tt>).
--   
--   Note that when recovery is in progress (see
--   <a>recoveryInProgress</a>), <a>triggerRecovery</a> does nothing. It's
--   okay because when recovery is in progress and <a>ncRecoveryHeader</a>
--   is full, we'll be requesting blocks anyway and until we're finished we
--   shouldn't be asking for new blocks.
triggerRecovery :: forall ssc m. (SscWorkersClass ssc, WorkMode ssc m) => SendActions m -> m ()
requestTipOuts :: OutSpecs

-- | Is used if we're recovering after offline and want to know what's
--   current blockchain state. Sends "what's your current tip" request to
--   everybody we know.
requestTip :: forall ssc s m. (SscWorkersClass ssc, WorkMode ssc m) => Proxy s -> NodeId -> ConversationActions MsgGetHeaders (LimitedLength s (MsgHeaders ssc)) m -> m ()
handleUnsolicitedHeaders :: forall ssc s m. (SscWorkersClass ssc, WorkMode ssc m) => NonEmpty (BlockHeader ssc) -> NodeId -> ConversationActions MsgGetHeaders (LimitedLength s (MsgHeaders ssc)) m -> m ()

-- | Make <tt>GetHeaders</tt> message using our main chain. This function
--   chooses appropriate <tt>from</tt> hashes and puts them into
--   <tt>GetHeaders</tt> message.
mkHeadersRequest :: forall ssc m. WorkMode ssc m => Maybe HeaderHash -> m (Maybe MsgGetHeaders)
requestHeaders :: forall ssc s m. (SscWorkersClass ssc, WorkMode ssc m) => MsgGetHeaders -> NodeId -> Maybe (BlockHeader ssc) -> Proxy s -> ConversationActions MsgGetHeaders (LimitedLength s (MsgHeaders ssc)) m -> m ()

-- | Make message which requests chain of blocks which is based on our tip.
--   LcaChild is the first block after LCA we don't know. WantedBlock is
--   the newest one we want to get.
mkBlocksRequest :: HeaderHash -> HeaderHash -> MsgGetBlocks
handleBlocks :: forall ssc m. (MonadDBCore m, SscWorkersClass ssc, WorkMode ssc m) => NodeId -> OldestFirst NE (Block ssc) -> SendActions m -> m ()
retrievalWorker :: forall ssc m. (MonadDBCore m, SscWorkersClass ssc, WorkMode ssc m) => (WorkerSpec m, OutSpecs)

-- | <tt>GetHeaders</tt> message. Behaviour of the response depends on
--   particular combination of <a>mghFrom</a> and <a>mghTo</a>.
--   
--   <ul>
--   <li><a>mghTo</a> resolves to some header (let's call it <tt>top</tt>
--   for convenience) -- node's tip if it's <tt>Nothing</tt>, header with
--   hash in <tt>Just</tt> if it's <tt>Just</tt>.</li>
--   <li>If <a>mghFrom</a> is empty, then semantics is "request to return
--   header of block <tt>top</tt>".</li>
--   <li>Otherwise (if <a>mghFrom</a> isn't empty) it represents the set of
--   checkpoints. Responding node will try to iterate headers from
--   <tt>top</tt> to older until it reaches any checkpoint. If it finds
--   checkpoint <tt>c</tt>, it returns all headers in range
--   <tt>[c.next..top]</tt>. If it doesn't find any checkpoint or depth of
--   searching exceeds <tt>recoveryHeadersMessage</tt>, it will try to find
--   the newest checkpoint <tt>cc</tt> from <a>mghFrom</a> that's in main
--   chain of responding node and then return at most
--   <tt>recoveryHeadersMessage</tt> headers starting with <tt>cc</tt> as
--   the oldest one, returning headers in range <tt>l2 = [cc.next..x]</tt>
--   where <tt>x</tt> is either <tt>top</tt> (in case <tt>length l2 &lt;
--   recoveryHeadersMessage</tt>) or some arbitrary header (and length is
--   precisely <tt>recoveryHeadersMessage</tt>).</li>
--   </ul>
data MsgGetHeaders
MsgGetHeaders :: ![HeaderHash] -> !(Maybe HeaderHash) -> MsgGetHeaders
[mghFrom] :: MsgGetHeaders -> ![HeaderHash]
[mghTo] :: MsgGetHeaders -> !(Maybe HeaderHash)

-- | <tt>GetBlocks</tt> message (see protocol specification).
data MsgGetBlocks
MsgGetBlocks :: !HeaderHash -> !HeaderHash -> MsgGetBlocks
[mgbFrom] :: MsgGetBlocks -> !HeaderHash
[mgbTo] :: MsgGetBlocks -> !HeaderHash

-- | <tt>Headers</tt> message (see protocol specification).
newtype MsgHeaders ssc
MsgHeaders :: (NewestFirst NE (BlockHeader ssc)) -> MsgHeaders ssc

-- | <a>Block</a> message (see protocol specification).
newtype MsgBlock ssc
MsgBlock :: (Block ssc) -> MsgBlock ssc

module Pos.Block.Arbitrary

-- | This type is used to generate a valid blockheader and associated
--   header verification params. With regards to the block header function
--   <a>verifyHeader</a>, the blockheaders that may be part of the
--   verification parameters are guaranteed to be valid, as are the slot
--   leaders and the current slot.
newtype HeaderAndParams ssc
HAndP :: (VerifyHeaderParams ssc, BlockHeader ssc) -> HeaderAndParams ssc
[getHAndP] :: HeaderAndParams ssc -> (VerifyHeaderParams ssc, BlockHeader ssc)
newtype BlockHeaderList ssc
BHL :: ([BlockHeader ssc], [PublicKey]) -> BlockHeaderList ssc
[getHeaderList] :: BlockHeaderList ssc -> ([BlockHeader ssc], [PublicKey])
newtype SmallTxPayload
SmallTxPayload :: TxPayload -> SmallTxPayload
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Show.Show (Pos.Block.Arbitrary.HeaderAndParams ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Block.Arbitrary.HeaderAndParams ssc)
instance Pos.Ssc.Class.Types.Ssc ssc => GHC.Classes.Eq (Pos.Block.Arbitrary.BlockHeaderList ssc)
instance Pos.Binary.Class.Bi Pos.Block.Arbitrary.SmallTxPayload
instance GHC.Classes.Eq Pos.Block.Arbitrary.SmallTxPayload
instance GHC.Show.Show Pos.Block.Arbitrary.SmallTxPayload
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Binary.Class.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Types.BlockSignature ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Block.Types.GenesisExtraHeaderData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Block.Types.GenesisExtraBodyData
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Types.GenesisBlockHeader ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Arbitrary.BodyDependsOnConsensus (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Core.Block.Body (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Core.Block.GenericBlock (Pos.Types.Block.Types.GenesisBlockchain ssc))
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Binary.Class.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Types.MainBlockHeader ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary h => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Data.Attributes.Attributes h)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Block.Types.MainExtraHeaderData
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Types.Block.Types.MainExtraBodyData
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Binary.Class.Raw) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Core.Block.BodyProof (Pos.Types.Block.Types.MainBlockchain ssc))
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Binary.Class.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Core.Block.ConsensusData (Pos.Types.Block.Types.MainBlockchain ssc))
instance (Pos.Ssc.Class.Types.Ssc ssc, Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc)) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Types.Block.Types.MainToSign ssc)
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Txp.Core.Types.TxPayload
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Block.Arbitrary.SmallTxPayload
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Arbitrary.SscPayloadDependsOnSlot ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Arbitrary.BodyDependsOnConsensus (Pos.Types.Block.Types.MainBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Core.Block.Body (Pos.Types.Block.Types.MainBlockchain ssc))
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Arbitrary.SscPayloadDependsOnSlot ssc), Pos.Ssc.Class.Helpers.SscHelpersClass ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Core.Block.GenericBlock (Pos.Types.Block.Types.MainBlockchain ssc))
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Block.Network.Types.MsgGetHeaders
instance Test.QuickCheck.Arbitrary.Arbitrary Pos.Block.Network.Types.MsgGetBlocks
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Pos.Binary.Class.Bi Pos.Binary.Class.Raw, Pos.Ssc.Class.Types.Ssc ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Network.Types.MsgHeaders ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscProof ssc), Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Arbitrary.SscPayloadDependsOnSlot ssc), Pos.Ssc.Class.Helpers.SscHelpersClass ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Network.Types.MsgBlock ssc)
instance Pos.Types.Block.Types.BiSsc ssc => Data.Text.Buildable.Buildable (Pos.Types.Block.Types.BlockHeader ssc, Pos.Crypto.Signing.PublicKey)
instance Pos.Types.Block.Types.BiSsc ssc => GHC.Show.Show (Pos.Block.Arbitrary.BlockHeaderList ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Helpers.SscHelpersClass ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Arbitrary.BlockHeaderList ssc)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Pos.Ssc.Class.Types.SscPayload ssc), Pos.Ssc.Class.Helpers.SscHelpersClass ssc) => Test.QuickCheck.Arbitrary.Arbitrary (Pos.Block.Arbitrary.HeaderAndParams ssc)

module Pos.Lrc

-- | Wrapper over <a>RichmenStake</a>. Its <a>Arbitrary</a> instance
--   enforces that the stake distribution inside must be invalid, i.e. one
--   of the stakeholders does not have sufficient coins to participate.
newtype InvalidRichmenStake thd
Invalid :: RichmenStake -> InvalidRichmenStake thd
[getInvalid] :: InvalidRichmenStake thd -> RichmenStake

-- | Wrapper over <a>RichmenStake</a>. Its <a>Arbitrary</a> instance
--   enforces that the stake distribution inside must be valid with respect
--   to the threshold <tt>thd</tt>, i.e. all of the coins are non-zero and
--   every stakeholder has sufficient coins (above 'coinPortionToDouble
--   thd' %) to participate. Using reflection, the <tt>thd</tt> phantom
--   type is used to get the threshold desired in each case.
newtype ValidRichmenStake thd
Valid :: RichmenStake -> ValidRichmenStake thd
[getValid] :: ValidRichmenStake thd -> RichmenStake
allLrcConsumers :: (SscWorkersClass ssc, WorkMode ssc m, MonadDBCore m) => [LrcConsumer m]
getLeaders :: MonadDB m => EpochIndex -> m (Maybe SlotLeaders)
putLeaders :: MonadDB m => EpochIndex -> SlotLeaders -> m ()
prepareLrcLeaders :: (WithNodeContext ssc m, MonadDB m) => m ()

-- | Put missing initial data into LRC DB.
prepareLrcDB :: (WithNodeContext ssc m, MonadDB m) => m ()
prepareLrcRichmen :: (WithNodeContext ssc m, MonadDB m) => m ()
data RCSsc
getRichmenSsc :: MonadDB m => EpochIndex -> m (Maybe RichmenStake)
putRichmenSsc :: (MonadDB m) => EpochIndex -> FullRichmenData -> m ()
data RCUs
getRichmenUS :: MonadDB m => EpochIndex -> m (Maybe FullRichmenData)
putRichmenUS :: (MonadDB m) => EpochIndex -> FullRichmenData -> m ()
data RCDlg
getRichmenDlg :: MonadDB m => EpochIndex -> m (Maybe Richmen)
putRichmenDlg :: MonadDB m => EpochIndex -> FullRichmenData -> m ()

-- | Find nodes which have at least 'eligibility threshold' coins.
findRichmenStake :: MonadIterator (StakeholderId, Coin) m => Coin -> m RichmenStake

-- | Pure version of findRichmen which uses in-memory Utxo.
findRichmenPure :: [(StakeholderId, Coin)] -> (Coin -> Coin) -> RichmenType -> FullRichmenData

-- | Function considers all variants of computation and compute using one
--   pass by stake DB and one pass by delegation DB.
findAllRichmenMaybe :: forall m. (MonadDB m, MonadIterator (StakeholderId, Coin) m) => Maybe Coin -> Maybe Coin -> m (RichmenStake, RichmenStake)

-- | Find delegated richmen.
findDelegatedRichmen :: (MonadDB m, MonadIterator (StakeholderId, Coin) m) => Coin -> m RichmenStake
data RichmenType
RTUsual :: RichmenType
RTDelegation :: (HashMap StakeholderId [StakeholderId]) -> RichmenType
lrcOnNewSlotWorker :: (SscWorkersClass ssc, WorkMode ssc m, MonadDBCore m) => (WorkerSpec m, OutSpecs)

-- | Run leaders and richmen computation for given epoch. If stable block
--   for this epoch is not known, LrcError will be thrown.
lrcSingleShot :: (SscWorkersClass ssc, WorkMode ssc m, MonadDBCore m) => EpochIndex -> m ()

-- | Same, but doesn't take lock on the semaphore.
lrcSingleShotNoLock :: (SscWorkersClass ssc, WorkMode ssc m, MonadDBCore m) => EpochIndex -> m ()

module Pos.Security.Workers
class Ssc ssc => SecurityWorkersClass ssc
securityWorkers :: (SecurityWorkersClass ssc, WorkMode ssc m) => Tagged ssc ([WorkerSpec m], OutSpecs)
instance Pos.Security.Class.SecurityWorkersClass Pos.Ssc.GodTossing.Type.SscGodTossing
instance Pos.Security.Class.SecurityWorkersClass Pos.Ssc.NistBeacon.SscNistBeacon


-- | High level workers.
module Pos.Worker

-- | All, but in reality not all, workers used by full node.
allWorkers :: (SscWorkersClass ssc, SecurityWorkersClass ssc, WorkMode ssc m, MonadDBCore m) => ([WorkerSpec m], OutSpecs)
allWorkersCount :: forall ssc m. (MonadDBCore m, SscWorkersClass ssc, SecurityWorkersClass ssc, WorkMode ssc m) => Int

module Pos.Launcher

-- | Run full node in real mode.
runNodeProduction :: forall ssc. SscConstraint ssc => PeerId -> Transport (ProductionMode ssc) -> KademliaDHTInstance -> ([WorkerSpec (ProductionMode ssc)], OutSpecs) -> NodeParams -> SscParams ssc -> Production ()

-- | Run full node in benchmarking node
runNodeStats :: forall ssc. SscConstraint ssc => PeerId -> Transport (StatsMode ssc) -> KademliaDHTInstance -> ([WorkerSpec (StatsMode ssc)], OutSpecs) -> NodeParams -> SscParams ssc -> Production ()
stakesDistr :: DistrOption -> DistrOption -> Maybe (Int, Int, Integer, Double) -> Bool -> StakeDistribution

-- | Contains all parameters required for hierarchical logger
--   initialization.
data LoggingParams
LoggingParams :: !LoggerName -> !(Maybe FilePath) -> !(Maybe FilePath) -> !(Maybe Int) -> LoggingParams

-- | Prefix for logger, like "time-slave"
[lpRunnerTag] :: LoggingParams -> !LoggerName

-- | Prefix of path for all logs
[lpHandlerPrefix] :: LoggingParams -> !(Maybe FilePath)

-- | Path to logger configuration
[lpConfigPath] :: LoggingParams -> !(Maybe FilePath)
[lpEkgPort] :: LoggingParams -> !(Maybe Int)

-- | Contains basic &amp; networking parameters for running node.
data BaseParams
BaseParams :: !LoggingParams -> BaseParams

-- | Logger parameters
[bpLoggingParams] :: BaseParams -> !LoggingParams

-- | Contains algorithm specific &amp; storage parameters for Node.
data NodeParams
NodeParams :: !FilePath -> !Bool -> !Timestamp -> !SecretKey -> !UserSecret -> !BaseParams -> !Utxo -> !(Maybe FilePath) -> ![AttackType] -> ![AttackTarget] -> !Bool -> ![Text] -> !UpdateParams -> !Bool -> NodeParams

-- | Path to node's database.
[npDbPathM] :: NodeParams -> !FilePath

-- | <tt>True</tt> if data-base should be rebuilt
[npRebuildDb] :: NodeParams -> !Bool

-- | System start
[npSystemStart] :: NodeParams -> !Timestamp

-- | Primary secret key of node
[npSecretKey] :: NodeParams -> !SecretKey

-- | All node secret keys
[npUserSecret] :: NodeParams -> !UserSecret

-- | See <a>BaseParams</a>
[npBaseParams] :: NodeParams -> !BaseParams

-- | predefined custom utxo
[npCustomUtxo] :: NodeParams -> !Utxo
[npJLFile] :: NodeParams -> !(Maybe FilePath)

-- | List of attack types used by malicious emulation
[npAttackTypes] :: NodeParams -> ![AttackType]

-- | List of targets to attack by malicious emulation
[npAttackTargets] :: NodeParams -> ![AttackTarget]

-- | Whether to propagate txs, ssc data, blocks to neighbors
[npPropagation] :: NodeParams -> !Bool

-- | List of report server URLs
[npReportServers] :: NodeParams -> ![Text]

-- | Params for update system
[npUpdateParams] :: NodeParams -> !UpdateParams
[npUseNTP] :: NodeParams -> !Bool

-- | RawRealMode runner.
runRawRealMode :: forall ssc a. SscConstraint ssc => PeerId -> Transport (RawRealMode ssc) -> NodeParams -> SscParams ssc -> RawRealMode ssc (ListenersWithOut (RawRealMode ssc)) -> OutSpecs -> ActionSpec (RawRealMode ssc) a -> Production a

-- | ProductionMode runner.
runProductionMode :: forall ssc a. (SscConstraint ssc) => PeerId -> Transport (ProductionMode ssc) -> KademliaDHTInstance -> NodeParams -> SscParams ssc -> (ActionSpec (ProductionMode ssc) a, OutSpecs) -> Production a

-- | StatsMode runner. [CSL-169]: spawn here additional listener, which
--   would accept stat queries can be done as part of refactoring (or
--   someone who will refactor will create new issue).
runStatsMode :: forall ssc a. (SscConstraint ssc) => PeerId -> Transport (StatsMode ssc) -> KademliaDHTInstance -> NodeParams -> SscParams ssc -> (ActionSpec (StatsMode ssc) a, OutSpecs) -> Production a

-- | ServiceMode runner.
runServiceMode :: PeerId -> Transport ServiceMode -> BaseParams -> ListenersWithOut ServiceMode -> OutSpecs -> ActionSpec ServiceMode a -> Production a
runStaticMode :: forall ssc a. (SscConstraint ssc) => PeerId -> Transport (StaticMode ssc) -> Set NodeId -> NodeParams -> SscParams ssc -> (ActionSpec (StaticMode ssc) a, OutSpecs) -> Production a
setupLoggers :: MonadIO m => LoggingParams -> m ()
bracketDHTInstance :: BaseParams -> KademliaParams -> (KademliaDHTInstance -> Production a) -> Production a
runServer :: (MonadIO m, MonadMockable m, MonadFix m, WithLogger m) => PeerId -> Transport m -> m (ListenersWithOut m) -> OutSpecs -> (Node m -> m t) -> (t -> m ()) -> ActionSpec m b -> m b
runServer_ :: (MonadIO m, MonadMockable m, MonadFix m, WithLogger m) => PeerId -> Transport m -> ListenersWithOut m -> OutSpecs -> ActionSpec m b -> m b

-- | RAII for node starter.
loggerBracket :: LoggingParams -> IO a -> IO a
createTransportTCP :: (MonadIO m, WithLogger m, Mockable Throw m) => TCPAddr -> m (Transport m)
bracketTransport :: TCPAddr -> (Transport Production -> Production a) -> Production a

-- | Bracket a transport for use with a static set of peers (for
--   discovery).
bracketResources :: BaseParams -> TCPAddr -> (Transport Production -> Production a) -> IO a

-- | Bracket a transport and a Kademlia node, using the latter for
--   discovery.
bracketResourcesKademlia :: BaseParams -> TCPAddr -> KademliaParams -> (KademliaDHTInstance -> Transport Production -> Production a) -> IO a

-- | Run full node in any WorkMode.
runNode :: (SscConstraint ssc, WorkMode ssc m, MonadDBCore m) => ([WorkerSpec m], OutSpecs) -> (WorkerSpec m, OutSpecs)
initSemaphore :: (WorkMode ssc m) => m ()
initLrc :: WorkMode ssc m => m ()

-- | Run full node in any WorkMode.
runNode' :: forall ssc m. (SscConstraint ssc, WorkMode ssc m, MonadDBCore m) => [WorkerSpec m] -> WorkerSpec m

module Pos.Wallet
class Monad m => MonadKeys m where getPrimaryKey = lift getPrimaryKey getSecretKeys = lift getSecretKeys addSecretKey = lift . addSecretKey deleteSecretKey = lift . deleteSecretKey
getPrimaryKey :: MonadKeys m => m (Maybe SecretKey)
getSecretKeys :: MonadKeys m => m [EncryptedSecretKey]
addSecretKey :: MonadKeys m => EncryptedSecretKey -> m ()
deleteSecretKey :: MonadKeys m => Word -> m ()
getPrimaryKey :: (MonadKeys m, MonadTrans t, MonadKeys m', t m' ~ m) => m (Maybe SecretKey)
getSecretKeys :: (MonadKeys m, MonadTrans t, MonadKeys m', t m' ~ m) => m [EncryptedSecretKey]
addSecretKey :: (MonadKeys m, MonadTrans t, MonadKeys m', t m' ~ m) => EncryptedSecretKey -> m ()
deleteSecretKey :: (MonadKeys m, MonadTrans t, MonadKeys m', t m' ~ m) => Word -> m ()

-- | Helper for generating a new secret key
newSecretKey :: (MonadIO m, MonadKeys m) => PassPhrase -> m EncryptedSecretKey
type KeyStorage = ReaderT KeyData
type KeyData = TVar UserSecret
data KeyError

-- | Failed attempt to delete primary key
PrimaryKey :: !Text -> KeyError
runKeyStorage :: (MonadIO m, WithLogger m) => FilePath -> KeyStorage m a -> m a
runKeyStorageRaw :: KeyStorage m a -> KeyData -> m a
data WalletParams
WalletParams :: !(Maybe FilePath) -> !Bool -> !FilePath -> Timestamp -> !Bool -> !BaseParams -> !Utxo -> WalletParams
[wpDbPath] :: WalletParams -> !(Maybe FilePath)
[wpRebuildDb] :: WalletParams -> !Bool
[wpKeyFilePath] :: WalletParams -> !FilePath
[wpSystemStart] :: WalletParams -> Timestamp
[wpGenesisKeys] :: WalletParams -> !Bool
[wpBaseParams] :: WalletParams -> !BaseParams

-- | Genesis utxo
[wpGenesisUtxo] :: WalletParams -> !Utxo
runRawStaticPeersWallet :: PeerId -> Transport WalletStaticPeersMode -> Set NodeId -> WalletParams -> ListenersWithOut WalletStaticPeersMode -> (ActionSpec WalletStaticPeersMode a, OutSpecs) -> Production a

-- | WalletMode runner
runWalletStaticPeersMode :: PeerId -> Transport WalletStaticPeersMode -> Set NodeId -> WalletParams -> (ActionSpec WalletStaticPeersMode a, OutSpecs) -> Production a
runWalletStaticPeers :: PeerId -> Transport WalletStaticPeersMode -> Set NodeId -> WalletParams -> ([WorkerSpec WalletStaticPeersMode], OutSpecs) -> Production ()
runWallet :: WalletMode ssc m => ([WorkerSpec m], OutSpecs) -> (WorkerSpec m, OutSpecs)

-- | Send UpdateVote to given addresses
submitVote :: (MinWorkMode m, MonadDBLimits m) => SendActions m -> [NodeId] -> UpdateVote -> m ()

-- | Send UpdateProposal with one positive vote to given addresses
submitUpdateProposal :: (MinWorkMode m, MonadDBLimits m) => SendActions m -> SafeSigner -> [NodeId] -> UpdateProposal -> m ()
sendVoteOuts :: OutSpecs
sendProposalOuts :: OutSpecs

-- | A class which have the methods to get state of address' balance
class Monad m => MonadBalances m where getOwnUtxo = lift . getOwnUtxo getBalance = lift . getBalance
getOwnUtxo :: MonadBalances m => Address -> m Utxo
getBalance :: MonadBalances m => Address -> m Coin
getOwnUtxo :: (MonadBalances m, MonadTrans t, MonadBalances m', t m' ~ m) => Address -> m Utxo
getBalance :: (MonadBalances m, MonadTrans t, MonadBalances m', t m' ~ m) => Address -> m Coin

-- | A class which have methods to get transaction history
class Monad m => MonadTxHistory m where getTxHistory = fmap lift <<$>> getTxHistory saveTx = lift . saveTx
getTxHistory :: (MonadTxHistory m, SscHelpersClass ssc) => Tagged ssc (Address -> Maybe (HeaderHash, Utxo) -> m TxHistoryAnswer)
saveTx :: MonadTxHistory m => (TxId, TxAux) -> m ()
getTxHistory :: (MonadTxHistory m, SscHelpersClass ssc, MonadTrans t, MonadTxHistory m', t m' ~ m) => Tagged ssc (Address -> Maybe (HeaderHash, Utxo) -> m TxHistoryAnswer)
saveTx :: (MonadTxHistory m, MonadTrans t, MonadTxHistory m', t m' ~ m) => (TxId, TxAux) -> m ()
class Monad m => MonadBlockchainInfo m where networkChainDifficulty = lift networkChainDifficulty localChainDifficulty = lift localChainDifficulty blockchainSlotDuration = lift blockchainSlotDuration connectedPeers = lift connectedPeers
networkChainDifficulty :: MonadBlockchainInfo m => m (Maybe ChainDifficulty)
localChainDifficulty :: MonadBlockchainInfo m => m ChainDifficulty
blockchainSlotDuration :: MonadBlockchainInfo m => m Millisecond
connectedPeers :: MonadBlockchainInfo m => m Word
networkChainDifficulty :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m (Maybe ChainDifficulty)
localChainDifficulty :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m ChainDifficulty
blockchainSlotDuration :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m Millisecond
connectedPeers :: (MonadBlockchainInfo m, MonadTrans t, MonadBlockchainInfo m', t m' ~ m) => m Word

-- | Abstraction over getting update proposals
class Monad m => MonadUpdates m where waitForUpdate = lift waitForUpdate applyLastUpdate = lift applyLastUpdate
waitForUpdate :: MonadUpdates m => m ConfirmedProposalState
applyLastUpdate :: MonadUpdates m => m ()
waitForUpdate :: (MonadUpdates m, MonadTrans t, MonadUpdates m', t m' ~ m) => m ConfirmedProposalState
applyLastUpdate :: (MonadUpdates m, MonadTrans t, MonadUpdates m', t m' ~ m) => m ()
type WalletMode ssc m = (TxMode ssc m, MonadKeys m, MonadBlockchainInfo m, MonadUpdates m, WithPeerState m, MonadDiscovery m)
type WalletRealMode = DiscoveryKademliaT RawWalletMode
type WalletStaticPeersMode = DiscoveryConstT RawWalletMode

module Pos.Wallet.Web

-- | Servant API which provides access to wallet. TODO: Should be composed
--   depending on the resource - wallets, txs, ...
--   <a>http://haskell-servant.github.io/tutorial/0.4/server.html#nested-apis</a>
type WalletApi = TestReset :<|> (GetWallet :<|> (GetWallets :<|> (UpdateWallet :<|> (DeleteWallet :<|> (ImportKey :<|> (WalletRestore :<|> (NewWallet :<|> (IsValidAddress :<|> (GetProfile :<|> (UpdateProfile :<|> (NewPayment :<|> (NewPaymentExt :<|> (UpdateTx :<|> (GetHistory :<|> (SearchHistory :<|> (NextUpdate :<|> (ApplyUpdate :<|> (RedeemADA :<|> (RedeemADAPaperVend :<|> (ReportingInitialized :<|> (ReportingElectroncrash :<|> (GetSlotsDuration :<|> (GetVersion :<|> GetSyncProgress)))))))))))))))))))))))

-- | Helper Proxy.
walletApi :: Proxy WalletApi

-- | All endpoints are defined as a separate types, for description in
--   Swagger-based HTML-documentation.
type TestReset = API :> ("test" :> ("reset" :> Post '[JSON] (Either WalletError ())))
type GetWallet = API :> ("wallets" :> (Capture "walletId" CAddress :> Get '[JSON] (Either WalletError CWallet)))
type GetWallets = API :> ("wallets" :> Get '[JSON] (Either WalletError [CWallet]))
type UpdateWallet = API :> ("wallets" :> (Capture "walletId" CAddress :> (ReqBody '[JSON] CWalletMeta :> Put '[JSON] (Either WalletError CWallet))))
type DeleteWallet = API :> ("wallets" :> (Capture "walletId" CAddress :> Delete '[JSON] (Either WalletError ())))
type ImportKey = API :> ("wallets" :> ("keys" :> (ReqBody '[JSON] Text :> Post '[JSON] (Either WalletError CWallet))))
type WalletRestore = API :> ("wallets" :> ("restore" :> (Capture "passphrase" CPassPhrase :> (ReqBody '[JSON] CWalletInit :> Post '[JSON] (Either WalletError CWallet)))))
type NewWallet = API :> ("wallets" :> (Capture "passphrase" CPassPhrase :> (ReqBody '[JSON] CWalletInit :> Post '[JSON] (Either WalletError CWallet))))
type IsValidAddress = API :> ("addresses" :> (Capture "address" Text :> ("currencies" :> (Capture "currency" CCurrency :> Get '[JSON] (Either WalletError Bool)))))
type GetProfile = API :> ("profile" :> Get '[JSON] (Either WalletError CProfile))
type UpdateProfile = API :> ("profile" :> (ReqBody '[JSON] CProfile :> Post '[JSON] (Either WalletError CProfile)))
type NewPayment = API :> ("txs" :> ("payments" :> (Capture "passphrase" CPassPhrase :> (Capture "from" CAddress :> (Capture "to" CAddress :> (Capture "amount" Coin :> Post '[JSON] (Either WalletError CTx)))))))
type NewPaymentExt = API :> ("txs" :> ("payments" :> (Capture "passphrase" CPassPhrase :> (Capture "from" CAddress :> (Capture "to" CAddress :> (Capture "amount" Coin :> (Capture "currency" CCurrency :> (Capture "title" Text :> (Capture "description" Text :> Post '[JSON] (Either WalletError CTx))))))))))
type UpdateTx = API :> ("txs" :> ("payments" :> (Capture "address" CAddress :> (Capture "transaction" CTxId :> (ReqBody '[JSON] CTxMeta :> Post '[JSON] (Either WalletError ()))))))
type GetHistory = API :> ("txs" :> ("histories" :> (Capture "address" CAddress :> (QueryParam "skip" Word :> (QueryParam "limit" Word :> Get '[JSON] (Either WalletError ([CTx], Word)))))))
type SearchHistory = API :> ("txs" :> ("histories" :> (Capture "address" CAddress :> (Capture "search" Text :> (QueryParam "skip" Word :> (QueryParam "limit" Word :> Get '[JSON] (Either WalletError ([CTx], Word))))))))
type NextUpdate = API :> ("update" :> Get '[JSON] (Either WalletError CUpdateInfo))
type ApplyUpdate = API :> ("update" :> Post '[JSON] (Either WalletError ()))
type RedeemADA = API :> ("redemptions" :> ("ada" :> (ReqBody '[JSON] CWalletRedeem :> Post '[JSON] (Either WalletError CTx))))
type RedeemADAPaperVend = API :> ("papervend" :> ("redemptions" :> ("ada" :> (ReqBody '[JSON] CPaperVendWalletRedeem :> Post '[JSON] (Either WalletError CTx)))))
type ReportingInitialized = API :> ("reporting" :> ("initialized" :> (ReqBody '[JSON] CInitialized :> Post '[JSON] (Either WalletError ()))))
type ReportingElectroncrash = API :> ("reporting" :> ("electroncrash" :> (MultipartForm CElectronCrashReport :> Post '[JSON] (Either WalletError ()))))
type GetSlotsDuration = API :> ("settings" :> ("slots" :> ("duration" :> Get '[JSON] (Either WalletError Word))))
type GetVersion = API :> ("settings" :> ("version" :> Get '[JSON] (Either WalletError SoftwareVersion)))
type GetSyncProgress = API :> ("settings" :> ("sync" :> ("progress" :> Get '[JSON] (Either WalletError SyncProgress))))
data SyncProgress
SyncProgress :: ChainDifficulty -> Maybe ChainDifficulty -> Word -> SyncProgress
[_spLocalCD] :: SyncProgress -> ChainDifficulty
[_spNetworkCD] :: SyncProgress -> Maybe ChainDifficulty
[_spPeers] :: SyncProgress -> Word

-- | Client address
newtype CAddress
CAddress :: CHash -> CAddress

-- | Currencies handled by client. Note: Cryptokami does not deal with other
--   currency than ADA yet.
data CCurrency
ADA :: CCurrency
BTC :: CCurrency
ETH :: CCurrency

-- | Client hash
newtype CHash
CHash :: Text -> CHash

-- | type of transactions It can be an input <i> output </i> exchange
--   transaction CTInOut CTExMeta -- Ex == exchange
data CTType
CTIn :: CTxMeta -> CTType
CTOut :: CTxMeta -> CTType
newtype CPassPhrase
CPassPhrase :: Text -> CPassPhrase

-- | Client profile (CP) all data of client are "meta data" - that is not
--   provided by Cryptokami (Flow type: accountType)
data CProfile
CProfile :: Text -> CProfile
[cpLocale] :: CProfile -> Text

-- | Password hash of client profile
type CPwHash = Text

-- | Client transaction (CTx) Provides all Data about a transaction needed
--   by client. It includes meta data which are not part of Cryptokami, too
--   (Flow type: transactionType)
data CTx
CTx :: !CTxId -> !CCoin -> ![(CAddress, CCoin)] -> ![(CAddress, CCoin)] -> !Word -> !CTType -> CTx
[ctId] :: CTx -> !CTxId
[ctAmount] :: CTx -> !CCoin
[ctFrom] :: CTx -> ![(CAddress, CCoin)]
[ctTo] :: CTx -> ![(CAddress, CCoin)]
[ctConfirmations] :: CTx -> !Word
[ctType] :: CTx -> !CTType

-- | Client transaction id
data CTxId

-- | meta data of transactions
data CTxMeta
CTxMeta :: CCurrency -> Text -> Text -> POSIXTime -> CTxMeta
[ctmCurrency] :: CTxMeta -> CCurrency
[ctmTitle] :: CTxMeta -> Text
[ctmDescription] :: CTxMeta -> Text
[ctmDate] :: CTxMeta -> POSIXTime

-- | meta data of exchanges
data CTExMeta
CTExMeta :: CCurrency -> Text -> Text -> POSIXTime -> Text -> Text -> CAddress -> CTExMeta
[cexCurrency] :: CTExMeta -> CCurrency
[cexTitle] :: CTExMeta -> Text
[cexDescription] :: CTExMeta -> Text
[cexDate] :: CTExMeta -> POSIXTime
[cexRate] :: CTExMeta -> Text
[cexLabel] :: CTExMeta -> Text
[cexAddress] :: CTExMeta -> CAddress

-- | Represents a knowledge about how much time did it take for client
--   (wallet) to initialize. All numbers are milliseconds.
data CInitialized
CInitialized :: Word -> Word -> CInitialized

-- | Total time from very start to main post-sync screen.
[cTotalTime] :: CInitialized -> Word

-- | Time passed from beginning to network connection with peers
--   established.
[cPreInit] :: CInitialized -> Word

-- | Client Wallet (CW) (Flow type: walletType)
data CWallet
CWallet :: !CAddress -> !CCoin -> !CWalletMeta -> CWallet
[cwAddress] :: CWallet -> !CAddress
[cwAmount] :: CWallet -> !CCoin
[cwMeta] :: CWallet -> !CWalletMeta

-- | A wallet can be used as personal or shared wallet
data CWalletType
CWTPersonal :: CWalletType
CWTShared :: CWalletType

-- | A level of assurance for the wallet "meta type"
data CWalletAssurance
CWAStrict :: CWalletAssurance
CWANormal :: CWalletAssurance

-- | Meta data of CWallet Includes data which are not provided by Cryptokami
data CWalletMeta
CWalletMeta :: !CWalletType -> !CCurrency -> !Text -> !CWalletAssurance -> !Int -> CWalletMeta
[cwType] :: CWalletMeta -> !CWalletType
[cwCurrency] :: CWalletMeta -> !CCurrency
[cwName] :: CWalletMeta -> !Text
[cwAssurance] :: CWalletMeta -> !CWalletAssurance

-- | <a>https://issues.serokell.io/issue/CSM-163#comment=96-2480</a>
[cwUnit] :: CWalletMeta -> !Int

-- | Query data for wallet creation (wallet meta + backup phrase)
data CWalletInit
CWalletInit :: !BackupPhrase -> !CWalletMeta -> CWalletInit
[cwBackupPhrase] :: CWalletInit -> !BackupPhrase
[cwInitMeta] :: CWalletInit -> !CWalletMeta

-- | Update system data
data CUpdateInfo
CUpdateInfo :: !SoftwareVersion -> !BlockVersion -> !ScriptVersion -> !Bool -> !Int -> !Int -> !CCoin -> !CCoin -> CUpdateInfo
[cuiSoftwareVersion] :: CUpdateInfo -> !SoftwareVersion
[cuiBlockVesion] :: CUpdateInfo -> !BlockVersion
[cuiScriptVersion] :: CUpdateInfo -> !ScriptVersion
[cuiImplicit] :: CUpdateInfo -> !Bool
[cuiVotesFor] :: CUpdateInfo -> !Int
[cuiVotesAgainst] :: CUpdateInfo -> !Int
[cuiPositiveStake] :: CUpdateInfo -> !CCoin
[cuiNegativeStake] :: CUpdateInfo -> !CCoin

-- | Query data for redeem
data CWalletRedeem
CWalletRedeem :: !CAddress -> !Text -> CWalletRedeem
[crWalletId] :: CWalletRedeem -> !CAddress
[crSeed] :: CWalletRedeem -> !Text

-- | Query data for redeem
data CPaperVendWalletRedeem
CPaperVendWalletRedeem :: !CAddress -> !Text -> !BackupPhrase -> CPaperVendWalletRedeem
[pvWalletId] :: CPaperVendWalletRedeem -> !CAddress
[pvSeed] :: CPaperVendWalletRedeem -> !Text
[pvBackupPhrase] :: CPaperVendWalletRedeem -> !BackupPhrase
data CCoin
mkCCoin :: Coin -> CCoin
data CElectronCrashReport
CElectronCrashReport :: Text -> Text -> Text -> Text -> Text -> Text -> Text -> Text -> FileData -> CElectronCrashReport
[cecVersion] :: CElectronCrashReport -> Text
[cecPlatform] :: CElectronCrashReport -> Text
[cecProcessType] :: CElectronCrashReport -> Text
[cecGuid] :: CElectronCrashReport -> Text
[cecVersionJson] :: CElectronCrashReport -> Text
[cecProductName] :: CElectronCrashReport -> Text
[cecProd] :: CElectronCrashReport -> Text
[cecCompanyName] :: CElectronCrashReport -> Text
[cecUploadDump] :: CElectronCrashReport -> FileData
data NotifyEvent
ConnectionOpened :: NotifyEvent
NetworkDifficultyChanged :: ChainDifficulty -> NotifyEvent
LocalDifficultyChanged :: ChainDifficulty -> NotifyEvent
ConnectedPeersChanged :: Word -> NotifyEvent
UpdateAvailable :: NotifyEvent
ConnectionClosed :: NotifyEvent

-- | Transform Address into CAddress
addressToCAddress :: Address -> CAddress
cAddressToAddress :: CAddress -> Either Text Address
passPhraseToCPassPhrase :: PassPhrase -> CPassPhrase
cPassPhraseToPassPhrase :: CPassPhrase -> Either Text PassPhrase
mkCTx :: Address -> ChainDifficulty -> TxHistoryEntry -> CTxMeta -> CTx
mkCTxId :: Text -> CTxId

-- | transform TxId into CTxId
txIdToCTxId :: TxId -> CTxId
txContainsTitle :: Text -> CTx -> Bool

-- | Creates <tt>CTUpdateInfo</tt> from <a>ConfirmedProposalState</a>
toCUpdateInfo :: ConfirmedProposalState -> CUpdateInfo
walletDocsText :: Text
walletTableDocsText :: Text
data WalletError

-- | Some internal error.
Internal :: !Text -> WalletError
walletServeWebFull :: forall ssc. (SscConstraint ssc) => SendActions (RawRealModeK ssc) -> Bool -> FilePath -> Bool -> Word16 -> RawRealModeK ssc ()
walletServerOuts :: OutSpecs
walletServeWebLite :: forall ssc. SscHelpersClass ssc => Proxy ssc -> SendActions WalletStaticPeersMode -> FilePath -> Bool -> Word16 -> WalletStaticPeersMode ()
walletServerOuts :: OutSpecs
type WalletWebHandler m = WalletWebSockets (WalletWebDB m)
walletApplication :: WalletWebMode m => m (Server WalletApi) -> m Application
walletServer :: (Monad m, MonadIO m, WalletWebMode (WalletWebHandler m)) => SendActions m -> WalletWebHandler m (WalletWebHandler m :~> Handler) -> WalletWebHandler m (Server WalletApi)
walletServeImpl :: (MonadIO m, MonadMask m, WalletWebMode (WalletWebHandler m)) => WalletWebHandler m Application -> FilePath -> Bool -> Word16 -> m ()
walletServerOuts :: OutSpecs

-- | Holder for web wallet data
type WalletWebSockets = ReaderT ConnectionsVar
type WebWalletSockets m = (MonadWalletWebSockets m, MonadIO m)

-- | MonadWalletWebSockets stands for monad which is able to get web wallet
--   sockets
type MonadWalletWebSockets = MonadReader ConnectionsVar
getWalletWebSockets :: MonadWalletWebSockets m => m ConnectionsVar
type ConnectionsVar = TVar (Maybe Connection)
initWSConnection :: MonadIO m => m ConnectionsVar
closeWSConnection :: MonadIO m => ConnectionsVar -> m ()
upgradeApplicationWS :: ConnectionsVar -> Application -> Application
notify :: WebWalletSockets m => NotifyEvent -> m ()
runWalletWS :: ConnectionsVar -> WalletWebSockets m a -> m a

-- | Holder for web wallet data
type WalletWebDB = ReaderT WalletState

-- | Execute <a>WalletWebDB</a> action with given <a>WalletState</a>
runWalletWebDB :: WalletState -> WalletWebDB m a -> m a
getWalletState :: Monad m => WalletWebDB m WalletState
type WalletState = ExtendedState WalletStorage

-- | MonadWalletWebDB stands for monad which is able to get web wallet
--   state
type MonadWalletWebDB = MonadReader WalletState
getWalletWebState :: MonadWalletWebDB m => m WalletState

-- | Constraint for working with web wallet DB
type WebWalletModeDB m = (MonadWalletWebDB m, MonadIO m, MonadMockable m)
openState :: MonadIO m => Bool -> FilePath -> m WalletState
openMemState :: MonadIO m => m WalletState
closeState :: MonadIO m => WalletState -> m ()
getProfile :: WebWalletModeDB m => m CProfile
getWalletMetas :: WebWalletModeDB m => m [CWalletMeta]
getWalletMeta :: WebWalletModeDB m => CAddress -> m (Maybe CWalletMeta)
getTxMeta :: WebWalletModeDB m => CAddress -> CTxId -> m (Maybe CTxMeta)
getWalletHistory :: WebWalletModeDB m => CAddress -> m (Maybe [CTxMeta])
getUpdates :: WebWalletModeDB m => m [CUpdateInfo]
getNextUpdate :: WebWalletModeDB m => m (Maybe CUpdateInfo)
getHistoryCache :: WebWalletModeDB m => CAddress -> m (Maybe (HeaderHash, Utxo, [TxHistoryEntry]))
testReset :: WebWalletModeDB m => m ()
createWallet :: WebWalletModeDB m => CAddress -> CWalletMeta -> m ()
setProfile :: WebWalletModeDB m => CProfile -> m ()
setWalletMeta :: WebWalletModeDB m => CAddress -> CWalletMeta -> m ()
setWalletTransactionMeta :: WebWalletModeDB m => CAddress -> CTxId -> CTxMeta -> m ()
setWalletHistory :: WebWalletModeDB m => CAddress -> [(CTxId, CTxMeta)] -> m ()
addOnlyNewTxMeta :: WebWalletModeDB m => CAddress -> CTxId -> CTxMeta -> m ()
removeWallet :: WebWalletModeDB m => CAddress -> m ()
addUpdate :: WebWalletModeDB m => CUpdateInfo -> m ()
removeNextUpdate :: WebWalletModeDB m => m ()
updateHistoryCache :: WebWalletModeDB m => CAddress -> HeaderHash -> Utxo -> [TxHistoryEntry] -> m ()
